//
// AccountsBalanceGetResponsePaymentRiskAssessment.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** This object provides detailed risk assessment for the requested transaction */
public struct AccountsBalanceGetResponsePaymentRiskAssessment: Codable, JSONEncodable, Hashable {

    static let scoreRule = NumericRule<Int>(minimum: 1, exclusiveMinimum: false, maximum: 99, exclusiveMaximum: false, multipleOf: nil)
    /** A five-tier risk assessment for the transaction, based on the probability of ACH returns, measured by the incident rate. */
    public var riskLevel: String?
    public var attributes: BalancePlusAttributes?
    /** A risk score ranging from 1-99, reflecting the likelihood of ACH debit return. A higher score indicates a greater risk of return, often due to overdrawn accounts or account ineligibility to receive ACH transactions. Typical return codes include \"R01\", \"R02\", \"R03\", \"R04\", \"R06\", \"R08\", \"R09\", \"R13\", \"R16\", \"R17\", \"R20\", \"R23\", etc., with a turnaround of 2 banking days. */
    public var score: Int?
    /** Timestamp of the last successful balance update, in [ISO 8601](https://wikipedia.org/wiki/ISO_8601) format. */
    public var balanceLastUpdated: Date?
    /** An array of objects, each representing a specific reason contributing to the risk assessment of an ACH transaction. This field is particularly useful for understanding risk factors affecting the risk level assigned to a transaction classified as “high”, “medium-high”, and “medium” risk. */
    public var riskReasons: [RiskReason]?
    /** This boolean field denotes if the requested ACH debit amount exceeds the calculated threshold based on either the available or current balance of the bank account. Specifically, it checks if the amount is greater than the account balance multiplied by \"balance_threshold_percentage\"/100. In cases where available_balance is not accessible, current_balance is used. This field is particularly useful for clients handling indirect items who lack direct access to raw balance data. */
    public var exceedsBalanceThreshold: Bool?

    public init(riskLevel: String? = nil, attributes: BalancePlusAttributes? = nil, score: Int? = nil, balanceLastUpdated: Date? = nil, riskReasons: [RiskReason]? = nil, exceedsBalanceThreshold: Bool? = nil) {
        self.riskLevel = riskLevel
        self.attributes = attributes
        self.score = score
        self.balanceLastUpdated = balanceLastUpdated
        self.riskReasons = riskReasons
        self.exceedsBalanceThreshold = exceedsBalanceThreshold
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case riskLevel = "risk_level"
        case attributes
        case score
        case balanceLastUpdated = "balance_last_updated"
        case riskReasons = "risk_reasons"
        case exceedsBalanceThreshold = "exceeds_balance_threshold"
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(riskLevel, forKey: .riskLevel)
        try container.encodeIfPresent(attributes, forKey: .attributes)
        try container.encodeIfPresent(score, forKey: .score)
        try container.encodeIfPresent(balanceLastUpdated, forKey: .balanceLastUpdated)
        try container.encodeIfPresent(riskReasons, forKey: .riskReasons)
        try container.encodeIfPresent(exceedsBalanceThreshold, forKey: .exceedsBalanceThreshold)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        riskLevel = try container.decodeIfPresent(String.self, forKey: .riskLevel)
        attributes = try container.decodeIfPresent(BalancePlusAttributes.self, forKey: .attributes)
        score = try container.decodeIfPresent(Int.self, forKey: .score)
        balanceLastUpdated = try container.decodeIfPresent(Date.self, forKey: .balanceLastUpdated)
        riskReasons = try container.decodeIfPresent([RiskReason].self, forKey: .riskReasons)
        exceedsBalanceThreshold = try container.decodeIfPresent(Bool.self, forKey: .exceedsBalanceThreshold)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("risk_level")
        nonAdditionalPropertyKeys.insert("attributes")
        nonAdditionalPropertyKeys.insert("score")
        nonAdditionalPropertyKeys.insert("balance_last_updated")
        nonAdditionalPropertyKeys.insert("risk_reasons")
        nonAdditionalPropertyKeys.insert("exceeds_balance_threshold")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

