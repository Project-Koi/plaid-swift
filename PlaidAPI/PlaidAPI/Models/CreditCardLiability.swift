//
// CreditCardLiability.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** An object representing a credit card account. */
public struct CreditCardLiability: Codable, JSONEncodable, Hashable {

    /** The ID of the account that this liability belongs to. */
    public var accountId: String?
    /** The various interest rates that apply to the account. APR information is not provided by all card issuers; if APR data is not available, this array will be empty. */
    public var aprs: [APR]
    /** true if a payment is currently overdue. Availability for this field is limited. */
    public var isOverdue: Bool?
    /** The amount of the last payment. */
    public var lastPaymentAmount: Double?
    /** The date of the last payment. Dates are returned in an [ISO 8601](https://wikipedia.org/wiki/ISO_8601) format (YYYY-MM-DD). Availability for this field is limited. */
    public var lastPaymentDate: Date?
    /** The date of the last statement. Dates are returned in an [ISO 8601](https://wikipedia.org/wiki/ISO_8601) format (YYYY-MM-DD). */
    public var lastStatementIssueDate: Date?
    /** The total amount owed as of the last statement issued */
    public var lastStatementBalance: Double?
    /** The minimum payment due for the next billing cycle. */
    public var minimumPaymentAmount: Double?
    /** The due date for the next payment. The due date is `null` if a payment is not expected. Dates are returned in an [ISO 8601](https://wikipedia.org/wiki/ISO_8601) format (YYYY-MM-DD). */
    public var nextPaymentDueDate: Date?

    public init(accountId: String?, aprs: [APR], isOverdue: Bool?, lastPaymentAmount: Double?, lastPaymentDate: Date?, lastStatementIssueDate: Date?, lastStatementBalance: Double?, minimumPaymentAmount: Double?, nextPaymentDueDate: Date?) {
        self.accountId = accountId
        self.aprs = aprs
        self.isOverdue = isOverdue
        self.lastPaymentAmount = lastPaymentAmount
        self.lastPaymentDate = lastPaymentDate
        self.lastStatementIssueDate = lastStatementIssueDate
        self.lastStatementBalance = lastStatementBalance
        self.minimumPaymentAmount = minimumPaymentAmount
        self.nextPaymentDueDate = nextPaymentDueDate
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case accountId = "account_id"
        case aprs
        case isOverdue = "is_overdue"
        case lastPaymentAmount = "last_payment_amount"
        case lastPaymentDate = "last_payment_date"
        case lastStatementIssueDate = "last_statement_issue_date"
        case lastStatementBalance = "last_statement_balance"
        case minimumPaymentAmount = "minimum_payment_amount"
        case nextPaymentDueDate = "next_payment_due_date"
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(accountId, forKey: .accountId)
        try container.encode(aprs, forKey: .aprs)
        try container.encode(isOverdue, forKey: .isOverdue)
        try container.encode(lastPaymentAmount, forKey: .lastPaymentAmount)
        try container.encode(lastPaymentDate, forKey: .lastPaymentDate)
        try container.encode(lastStatementIssueDate, forKey: .lastStatementIssueDate)
        try container.encode(lastStatementBalance, forKey: .lastStatementBalance)
        try container.encode(minimumPaymentAmount, forKey: .minimumPaymentAmount)
        try container.encode(nextPaymentDueDate, forKey: .nextPaymentDueDate)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        accountId = try container.decodeIfPresent(String.self, forKey: .accountId)
        aprs = try container.decode([APR].self, forKey: .aprs)
        isOverdue = try container.decodeIfPresent(Bool.self, forKey: .isOverdue)
        lastPaymentAmount = try container.decodeIfPresent(Double.self, forKey: .lastPaymentAmount)
        lastPaymentDate = try container.decodeIfPresent(Date.self, forKey: .lastPaymentDate)
        lastStatementIssueDate = try container.decodeIfPresent(Date.self, forKey: .lastStatementIssueDate)
        lastStatementBalance = try container.decodeIfPresent(Double.self, forKey: .lastStatementBalance)
        minimumPaymentAmount = try container.decodeIfPresent(Double.self, forKey: .minimumPaymentAmount)
        nextPaymentDueDate = try container.decodeIfPresent(Date.self, forKey: .nextPaymentDueDate)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("account_id")
        nonAdditionalPropertyKeys.insert("aprs")
        nonAdditionalPropertyKeys.insert("is_overdue")
        nonAdditionalPropertyKeys.insert("last_payment_amount")
        nonAdditionalPropertyKeys.insert("last_payment_date")
        nonAdditionalPropertyKeys.insert("last_statement_issue_date")
        nonAdditionalPropertyKeys.insert("last_statement_balance")
        nonAdditionalPropertyKeys.insert("minimum_payment_amount")
        nonAdditionalPropertyKeys.insert("next_payment_due_date")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

