//
// SignalEvaluateResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** SignalEvaluateResponse defines the response schema for &#x60;/signal/income/evaluate&#x60; */
public struct SignalEvaluateResponse: Codable, JSONEncodable, Hashable {

    /** A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive. */
    public var requestId: String
    public var scores: SignalScores
    public var coreAttributes: SignalEvaluateCoreAttributes?
    public var riskProfile: RiskProfile?
    /** If bank information was not available to be used in the Signal model, this array contains warnings describing why bank data is missing. If you want to receive an API error instead of Signal scores in the case of missing bank data, file a support ticket or contact your Plaid account manager. */
    public var warnings: [SignalWarning]

    public init(requestId: String, scores: SignalScores, coreAttributes: SignalEvaluateCoreAttributes? = nil, riskProfile: RiskProfile? = nil, warnings: [SignalWarning]) {
        self.requestId = requestId
        self.scores = scores
        self.coreAttributes = coreAttributes
        self.riskProfile = riskProfile
        self.warnings = warnings
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case requestId = "request_id"
        case scores
        case coreAttributes = "core_attributes"
        case riskProfile = "risk_profile"
        case warnings
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(requestId, forKey: .requestId)
        try container.encode(scores, forKey: .scores)
        try container.encodeIfPresent(coreAttributes, forKey: .coreAttributes)
        try container.encodeIfPresent(riskProfile, forKey: .riskProfile)
        try container.encode(warnings, forKey: .warnings)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        requestId = try container.decode(String.self, forKey: .requestId)
        scores = try container.decode(SignalScores.self, forKey: .scores)
        coreAttributes = try container.decodeIfPresent(SignalEvaluateCoreAttributes.self, forKey: .coreAttributes)
        riskProfile = try container.decodeIfPresent(RiskProfile.self, forKey: .riskProfile)
        warnings = try container.decode([SignalWarning].self, forKey: .warnings)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("request_id")
        nonAdditionalPropertyKeys.insert("scores")
        nonAdditionalPropertyKeys.insert("core_attributes")
        nonAdditionalPropertyKeys.insert("risk_profile")
        nonAdditionalPropertyKeys.insert("warnings")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

