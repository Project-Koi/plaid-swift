//
// Security.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Contains details about a security */
public struct Security: Codable, JSONEncodable, Hashable {

    /** A unique, Plaid-specific identifier for the security, used to associate securities with holdings. Like all Plaid identifiers, the `security_id` is case sensitive. The `security_id` may change if inherent details of the security change due to a corporate action, for example, in the event of a ticker symbol change or CUSIP change. */
    public var securityId: String
    /** 12-character ISIN, a globally unique securities identifier. A verified CUSIP Global Services license is required to receive this data. This field will be null by default for new customers, and null for existing customers starting March 12, 2024. If you would like access to this field, please start the verification process [here](https://docs.google.com/forms/d/e/1FAIpQLSd9asHEYEfmf8fxJTHZTAfAzW4dugsnSu-HS2J51f1mxwd6Sw/viewform). */
    public var isin: String?
    /** 9-character CUSIP, an identifier assigned to North American securities. A verified CUSIP Global Services license is required to receive this data. This field will be null by default for new customers, and null for existing customers starting March 12, 2024. If you would like access to this field, please start the verification process [here](https://docs.google.com/forms/d/e/1FAIpQLSd9asHEYEfmf8fxJTHZTAfAzW4dugsnSu-HS2J51f1mxwd6Sw/viewform). */
    public var cusip: String?
    /** 7-character SEDOL, an identifier assigned to securities in the UK. */
    public var sedol: String?
    /** An identifier given to the security by the institution */
    public var institutionSecurityId: String?
    /** If `institution_security_id` is present, this field indicates the Plaid `institution_id` of the institution to whom the identifier belongs. */
    public var institutionId: String?
    /** In certain cases, Plaid will provide the ID of another security whose performance resembles this security, typically when the original security has low volume, or when a private security can be modeled with a publicly traded security. */
    public var proxySecurityId: String?
    /** A descriptive name for the security, suitable for display. */
    public var name: String?
    /** The securityâ€™s trading symbol for publicly traded securities, and otherwise a short identifier if available. */
    public var tickerSymbol: String?
    /** Indicates that a security is a highly liquid asset and can be treated like cash. */
    public var isCashEquivalent: Bool?
    /** The security type of the holding.  In rare instances, a null value is returned when institutional data is insufficient to determine the security type.  Valid security types are:  `cash`: Cash, currency, and money market funds  `cryptocurrency`: Digital or virtual currencies  `derivative`: Options, warrants, and other derivative instruments  `equity`: Domestic and foreign equities  `etf`: Multi-asset exchange-traded investment funds  `fixed income`: Bonds and certificates of deposit (CDs)  `loan`: Loans and loan receivables  `mutual fund`: Open- and closed-end vehicles pooling funds of multiple investors  `other`: Unknown or other investment types */
    public var type: String?
    /** Price of the security at the close of the previous trading session. Null for non-public securities.  If the security is a foreign currency this field will be updated daily and will be priced in USD.  If the security is a cryptocurrency, this field will be updated multiple times a day. As crypto prices can fluctuate quickly and data may become stale sooner than other asset classes, refer to `update_datetime` with the time when the price was last updated.  */
    public var closePrice: Double?
    /** Date for which `close_price` is accurate. Always `null` if `close_price` is `null`. */
    public var closePriceAsOf: Date?
    /** Date and time at which `close_price` is accurate, in ISO 8601 format (YYYY-MM-DDTHH:mm:ssZ). Always `null` if `close_price` is `null`. */
    public var updateDatetime: Date?
    /** The ISO-4217 currency code of the price given. Always `null` if `unofficial_currency_code` is non-`null`. */
    public var isoCurrencyCode: String?
    /** The unofficial currency code associated with the security. Always `null` if `iso_currency_code` is non-`null`. Unofficial currency codes are used for currencies that do not have official ISO currency codes, such as cryptocurrencies and the currencies of certain countries.  See the [currency code schema](https://plaid.com/docs/api/accounts#currency-code-schema) for a full listing of supported `iso_currency_code`s. */
    public var unofficialCurrencyCode: String?
    /** The ISO-10383 Market Identifier Code of the exchange or market in which the security is being traded. */
    public var marketIdentifierCode: String?
    public var optionContract: OptionContract?

    public init(securityId: String, isin: String?, cusip: String?, sedol: String?, institutionSecurityId: String?, institutionId: String?, proxySecurityId: String?, name: String?, tickerSymbol: String?, isCashEquivalent: Bool?, type: String?, closePrice: Double?, closePriceAsOf: Date?, updateDatetime: Date? = nil, isoCurrencyCode: String?, unofficialCurrencyCode: String?, marketIdentifierCode: String?, optionContract: OptionContract?) {
        self.securityId = securityId
        self.isin = isin
        self.cusip = cusip
        self.sedol = sedol
        self.institutionSecurityId = institutionSecurityId
        self.institutionId = institutionId
        self.proxySecurityId = proxySecurityId
        self.name = name
        self.tickerSymbol = tickerSymbol
        self.isCashEquivalent = isCashEquivalent
        self.type = type
        self.closePrice = closePrice
        self.closePriceAsOf = closePriceAsOf
        self.updateDatetime = updateDatetime
        self.isoCurrencyCode = isoCurrencyCode
        self.unofficialCurrencyCode = unofficialCurrencyCode
        self.marketIdentifierCode = marketIdentifierCode
        self.optionContract = optionContract
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case securityId = "security_id"
        case isin
        case cusip
        case sedol
        case institutionSecurityId = "institution_security_id"
        case institutionId = "institution_id"
        case proxySecurityId = "proxy_security_id"
        case name
        case tickerSymbol = "ticker_symbol"
        case isCashEquivalent = "is_cash_equivalent"
        case type
        case closePrice = "close_price"
        case closePriceAsOf = "close_price_as_of"
        case updateDatetime = "update_datetime"
        case isoCurrencyCode = "iso_currency_code"
        case unofficialCurrencyCode = "unofficial_currency_code"
        case marketIdentifierCode = "market_identifier_code"
        case optionContract = "option_contract"
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(securityId, forKey: .securityId)
        try container.encode(isin, forKey: .isin)
        try container.encode(cusip, forKey: .cusip)
        try container.encode(sedol, forKey: .sedol)
        try container.encode(institutionSecurityId, forKey: .institutionSecurityId)
        try container.encode(institutionId, forKey: .institutionId)
        try container.encode(proxySecurityId, forKey: .proxySecurityId)
        try container.encode(name, forKey: .name)
        try container.encode(tickerSymbol, forKey: .tickerSymbol)
        try container.encode(isCashEquivalent, forKey: .isCashEquivalent)
        try container.encode(type, forKey: .type)
        try container.encode(closePrice, forKey: .closePrice)
        try container.encode(closePriceAsOf, forKey: .closePriceAsOf)
        try container.encodeIfPresent(updateDatetime, forKey: .updateDatetime)
        try container.encode(isoCurrencyCode, forKey: .isoCurrencyCode)
        try container.encode(unofficialCurrencyCode, forKey: .unofficialCurrencyCode)
        try container.encode(marketIdentifierCode, forKey: .marketIdentifierCode)
        try container.encode(optionContract, forKey: .optionContract)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        securityId = try container.decode(String.self, forKey: .securityId)
        isin = try container.decodeIfPresent(String.self, forKey: .isin)
        cusip = try container.decodeIfPresent(String.self, forKey: .cusip)
        sedol = try container.decodeIfPresent(String.self, forKey: .sedol)
        institutionSecurityId = try container.decodeIfPresent(String.self, forKey: .institutionSecurityId)
        institutionId = try container.decodeIfPresent(String.self, forKey: .institutionId)
        proxySecurityId = try container.decodeIfPresent(String.self, forKey: .proxySecurityId)
        name = try container.decodeIfPresent(String.self, forKey: .name)
        tickerSymbol = try container.decodeIfPresent(String.self, forKey: .tickerSymbol)
        isCashEquivalent = try container.decodeIfPresent(Bool.self, forKey: .isCashEquivalent)
        type = try container.decodeIfPresent(String.self, forKey: .type)
        closePrice = try container.decodeIfPresent(Double.self, forKey: .closePrice)
        closePriceAsOf = try container.decodeIfPresent(Date.self, forKey: .closePriceAsOf)
        updateDatetime = try container.decodeIfPresent(Date.self, forKey: .updateDatetime)
        isoCurrencyCode = try container.decodeIfPresent(String.self, forKey: .isoCurrencyCode)
        unofficialCurrencyCode = try container.decodeIfPresent(String.self, forKey: .unofficialCurrencyCode)
        marketIdentifierCode = try container.decodeIfPresent(String.self, forKey: .marketIdentifierCode)
        optionContract = try container.decodeIfPresent(OptionContract.self, forKey: .optionContract)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("security_id")
        nonAdditionalPropertyKeys.insert("isin")
        nonAdditionalPropertyKeys.insert("cusip")
        nonAdditionalPropertyKeys.insert("sedol")
        nonAdditionalPropertyKeys.insert("institution_security_id")
        nonAdditionalPropertyKeys.insert("institution_id")
        nonAdditionalPropertyKeys.insert("proxy_security_id")
        nonAdditionalPropertyKeys.insert("name")
        nonAdditionalPropertyKeys.insert("ticker_symbol")
        nonAdditionalPropertyKeys.insert("is_cash_equivalent")
        nonAdditionalPropertyKeys.insert("type")
        nonAdditionalPropertyKeys.insert("close_price")
        nonAdditionalPropertyKeys.insert("close_price_as_of")
        nonAdditionalPropertyKeys.insert("update_datetime")
        nonAdditionalPropertyKeys.insert("iso_currency_code")
        nonAdditionalPropertyKeys.insert("unofficial_currency_code")
        nonAdditionalPropertyKeys.insert("market_identifier_code")
        nonAdditionalPropertyKeys.insert("option_contract")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

