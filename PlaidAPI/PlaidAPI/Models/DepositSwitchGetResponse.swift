//
// DepositSwitchGetResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** DepositSwitchGetResponse defines the response schema for &#x60;/deposit_switch/get&#x60; */
public struct DepositSwitchGetResponse: Codable, JSONEncodable, Hashable {

    public enum State: String, Codable, CaseIterable {
        case initialized = "initialized"
        case processing = "processing"
        case completed = "completed"
        case error = "error"
    }
    public enum SwitchMethod: String, Codable, CaseIterable {
        case instant = "instant"
        case mail = "mail"
        case pdf = "pdf"
        case null = "null"
    }
    /** The ID of the deposit switch. */
    public var depositSwitchId: String
    /** The ID of the bank account the direct deposit was switched to. */
    public var targetAccountId: String?
    /** The ID of the Item the direct deposit was switched to. */
    public var targetItemId: String?
    /**  The state, or status, of the deposit switch.  - `initialized` – The deposit switch has been initialized with the user entering the information required to submit the deposit switch request.  - `processing` – The deposit switch request has been submitted and is being processed.  - `completed` – The user's employer has fulfilled the deposit switch request.  - `error` – There was an error processing the deposit switch request. */
    public var state: State
    /** The method used to make the deposit switch.  - `instant` – User instantly switched their direct deposit to a new or existing bank account by connecting their payroll or employer account.  - `mail` – User requested that Plaid contact their employer by mail to make the direct deposit switch.  - `pdf` – User generated a PDF or email to be sent to their employer with the information necessary to make the deposit switch.' */
    public var switchMethod: SwitchMethod?
    /** When `true`, user’s direct deposit goes to multiple banks. When false, user’s direct deposit only goes to the target account. Always `null` if the deposit switch has not been completed. */
    public var accountHasMultipleAllocations: Bool?
    /** When `true`, the target account is allocated the remainder of direct deposit after all other allocations have been deducted. When `false`, user’s direct deposit is allocated as a percent or amount. Always `null` if the deposit switch has not been completed. */
    public var isAllocatedRemainder: Bool?
    /** The percentage of direct deposit allocated to the target account. Always `null` if the target account is not allocated a percentage or if the deposit switch has not been completed or if `is_allocated_remainder` is true. */
    public var percentAllocated: Double?
    /** The dollar amount of direct deposit allocated to the target account. Always `null` if the target account is not allocated an amount or if the deposit switch has not been completed. */
    public var amountAllocated: Double?
    /** The name of the employer selected by the user. If the user did not select an employer, the value returned is `null`. */
    public var employerName: String?
    /** The ID of the employer selected by the user. If the user did not select an employer, the value returned is `null`. */
    public var employerId: String?
    /** The name of the institution selected by the user. If the user did not select an institution, the value returned is `null`. */
    public var institutionName: String?
    /** The ID of the institution selected by the user. If the user did not select an institution, the value returned is `null`. */
    public var institutionId: String?
    /** [ISO 8601](https://wikipedia.org/wiki/ISO_8601) date the deposit switch was created.  */
    public var dateCreated: Date
    /** [ISO 8601](https://wikipedia.org/wiki/ISO_8601) date the deposit switch was completed. Always `null` if the deposit switch has not been completed.  */
    public var dateCompleted: Date?
    /** A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive. */
    public var requestId: String

    public init(depositSwitchId: String, targetAccountId: String?, targetItemId: String?, state: State, switchMethod: SwitchMethod? = nil, accountHasMultipleAllocations: Bool?, isAllocatedRemainder: Bool?, percentAllocated: Double?, amountAllocated: Double?, employerName: String? = nil, employerId: String? = nil, institutionName: String? = nil, institutionId: String? = nil, dateCreated: Date, dateCompleted: Date?, requestId: String) {
        self.depositSwitchId = depositSwitchId
        self.targetAccountId = targetAccountId
        self.targetItemId = targetItemId
        self.state = state
        self.switchMethod = switchMethod
        self.accountHasMultipleAllocations = accountHasMultipleAllocations
        self.isAllocatedRemainder = isAllocatedRemainder
        self.percentAllocated = percentAllocated
        self.amountAllocated = amountAllocated
        self.employerName = employerName
        self.employerId = employerId
        self.institutionName = institutionName
        self.institutionId = institutionId
        self.dateCreated = dateCreated
        self.dateCompleted = dateCompleted
        self.requestId = requestId
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case depositSwitchId = "deposit_switch_id"
        case targetAccountId = "target_account_id"
        case targetItemId = "target_item_id"
        case state
        case switchMethod = "switch_method"
        case accountHasMultipleAllocations = "account_has_multiple_allocations"
        case isAllocatedRemainder = "is_allocated_remainder"
        case percentAllocated = "percent_allocated"
        case amountAllocated = "amount_allocated"
        case employerName = "employer_name"
        case employerId = "employer_id"
        case institutionName = "institution_name"
        case institutionId = "institution_id"
        case dateCreated = "date_created"
        case dateCompleted = "date_completed"
        case requestId = "request_id"
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(depositSwitchId, forKey: .depositSwitchId)
        try container.encode(targetAccountId, forKey: .targetAccountId)
        try container.encode(targetItemId, forKey: .targetItemId)
        try container.encode(state, forKey: .state)
        try container.encodeIfPresent(switchMethod, forKey: .switchMethod)
        try container.encode(accountHasMultipleAllocations, forKey: .accountHasMultipleAllocations)
        try container.encode(isAllocatedRemainder, forKey: .isAllocatedRemainder)
        try container.encode(percentAllocated, forKey: .percentAllocated)
        try container.encode(amountAllocated, forKey: .amountAllocated)
        try container.encodeIfPresent(employerName, forKey: .employerName)
        try container.encodeIfPresent(employerId, forKey: .employerId)
        try container.encodeIfPresent(institutionName, forKey: .institutionName)
        try container.encodeIfPresent(institutionId, forKey: .institutionId)
        try container.encode(dateCreated, forKey: .dateCreated)
        try container.encode(dateCompleted, forKey: .dateCompleted)
        try container.encode(requestId, forKey: .requestId)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        depositSwitchId = try container.decode(String.self, forKey: .depositSwitchId)
        targetAccountId = try container.decodeIfPresent(String.self, forKey: .targetAccountId)
        targetItemId = try container.decodeIfPresent(String.self, forKey: .targetItemId)
        state = try container.decode(State.self, forKey: .state)
        switchMethod = try container.decodeIfPresent(SwitchMethod.self, forKey: .switchMethod)
        accountHasMultipleAllocations = try container.decodeIfPresent(Bool.self, forKey: .accountHasMultipleAllocations)
        isAllocatedRemainder = try container.decodeIfPresent(Bool.self, forKey: .isAllocatedRemainder)
        percentAllocated = try container.decodeIfPresent(Double.self, forKey: .percentAllocated)
        amountAllocated = try container.decodeIfPresent(Double.self, forKey: .amountAllocated)
        employerName = try container.decodeIfPresent(String.self, forKey: .employerName)
        employerId = try container.decodeIfPresent(String.self, forKey: .employerId)
        institutionName = try container.decodeIfPresent(String.self, forKey: .institutionName)
        institutionId = try container.decodeIfPresent(String.self, forKey: .institutionId)
        dateCreated = try container.decode(Date.self, forKey: .dateCreated)
        dateCompleted = try container.decodeIfPresent(Date.self, forKey: .dateCompleted)
        requestId = try container.decode(String.self, forKey: .requestId)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("deposit_switch_id")
        nonAdditionalPropertyKeys.insert("target_account_id")
        nonAdditionalPropertyKeys.insert("target_item_id")
        nonAdditionalPropertyKeys.insert("state")
        nonAdditionalPropertyKeys.insert("switch_method")
        nonAdditionalPropertyKeys.insert("account_has_multiple_allocations")
        nonAdditionalPropertyKeys.insert("is_allocated_remainder")
        nonAdditionalPropertyKeys.insert("percent_allocated")
        nonAdditionalPropertyKeys.insert("amount_allocated")
        nonAdditionalPropertyKeys.insert("employer_name")
        nonAdditionalPropertyKeys.insert("employer_id")
        nonAdditionalPropertyKeys.insert("institution_name")
        nonAdditionalPropertyKeys.insert("institution_id")
        nonAdditionalPropertyKeys.insert("date_created")
        nonAdditionalPropertyKeys.insert("date_completed")
        nonAdditionalPropertyKeys.insert("request_id")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

