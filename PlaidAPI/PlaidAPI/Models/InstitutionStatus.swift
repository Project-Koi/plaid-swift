//
// InstitutionStatus.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** The status of an institution is determined by the health of its Item logins, Transactions updates, Investments updates, Liabilities updates, Auth requests, Balance requests, Identity requests, Investments requests, and Liabilities requests. A login attempt is conducted during the initial Item add in Link. If there is not enough traffic to accurately calculate an institution&#39;s status, Plaid will return null rather than potentially inaccurate data.  Institution status is accessible in the Dashboard and via the API using the &#x60;/institutions/get_by_id&#x60; endpoint with the &#x60;include_status&#x60; option set to true. Note that institution status is not available in the Sandbox environment.  */
public struct InstitutionStatus: Codable, JSONEncodable, Hashable {

    public var itemLogins: ProductStatus?
    public var transactionsUpdates: ProductStatus?
    public var auth: ProductStatus?
    public var identity: ProductStatus?
    public var investmentsUpdates: ProductStatus?
    public var liabilitiesUpdates: ProductStatus?
    public var liabilities: ProductStatus?
    public var investments: ProductStatus?
    /** Details of recent health incidents associated with the institution. */
    public var healthIncidents: [HealthIncident]?

    public init(itemLogins: ProductStatus? = nil, transactionsUpdates: ProductStatus? = nil, auth: ProductStatus? = nil, identity: ProductStatus? = nil, investmentsUpdates: ProductStatus? = nil, liabilitiesUpdates: ProductStatus? = nil, liabilities: ProductStatus? = nil, investments: ProductStatus? = nil, healthIncidents: [HealthIncident]? = nil) {
        self.itemLogins = itemLogins
        self.transactionsUpdates = transactionsUpdates
        self.auth = auth
        self.identity = identity
        self.investmentsUpdates = investmentsUpdates
        self.liabilitiesUpdates = liabilitiesUpdates
        self.liabilities = liabilities
        self.investments = investments
        self.healthIncidents = healthIncidents
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case itemLogins = "item_logins"
        case transactionsUpdates = "transactions_updates"
        case auth
        case identity
        case investmentsUpdates = "investments_updates"
        case liabilitiesUpdates = "liabilities_updates"
        case liabilities
        case investments
        case healthIncidents = "health_incidents"
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(itemLogins, forKey: .itemLogins)
        try container.encodeIfPresent(transactionsUpdates, forKey: .transactionsUpdates)
        try container.encodeIfPresent(auth, forKey: .auth)
        try container.encodeIfPresent(identity, forKey: .identity)
        try container.encodeIfPresent(investmentsUpdates, forKey: .investmentsUpdates)
        try container.encodeIfPresent(liabilitiesUpdates, forKey: .liabilitiesUpdates)
        try container.encodeIfPresent(liabilities, forKey: .liabilities)
        try container.encodeIfPresent(investments, forKey: .investments)
        try container.encodeIfPresent(healthIncidents, forKey: .healthIncidents)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        itemLogins = try container.decodeIfPresent(ProductStatus.self, forKey: .itemLogins)
        transactionsUpdates = try container.decodeIfPresent(ProductStatus.self, forKey: .transactionsUpdates)
        auth = try container.decodeIfPresent(ProductStatus.self, forKey: .auth)
        identity = try container.decodeIfPresent(ProductStatus.self, forKey: .identity)
        investmentsUpdates = try container.decodeIfPresent(ProductStatus.self, forKey: .investmentsUpdates)
        liabilitiesUpdates = try container.decodeIfPresent(ProductStatus.self, forKey: .liabilitiesUpdates)
        liabilities = try container.decodeIfPresent(ProductStatus.self, forKey: .liabilities)
        investments = try container.decodeIfPresent(ProductStatus.self, forKey: .investments)
        healthIncidents = try container.decodeIfPresent([HealthIncident].self, forKey: .healthIncidents)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("item_logins")
        nonAdditionalPropertyKeys.insert("transactions_updates")
        nonAdditionalPropertyKeys.insert("auth")
        nonAdditionalPropertyKeys.insert("identity")
        nonAdditionalPropertyKeys.insert("investments_updates")
        nonAdditionalPropertyKeys.insert("liabilities_updates")
        nonAdditionalPropertyKeys.insert("liabilities")
        nonAdditionalPropertyKeys.insert("investments")
        nonAdditionalPropertyKeys.insert("health_incidents")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

