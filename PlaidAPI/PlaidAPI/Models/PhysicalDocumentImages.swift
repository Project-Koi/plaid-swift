//
// PhysicalDocumentImages.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** URLs for downloading original and cropped images for this document submission. The URLs are designed to only allow downloading, not hot linking, so the URL will only serve the document image for 60 seconds before expiring. The expiration time is 60 seconds after the &#x60;GET&#x60; request for the associated Identity Verification attempt. A new expiring URL is generated with each request, so you can always rerequest the Identity Verification attempt if one of your URLs expires. */
public struct PhysicalDocumentImages: Codable, JSONEncodable, Hashable {

    /** Temporary URL that expires after 60 seconds for downloading the uncropped original image of the front of the document. */
    public var originalFront: String?
    /** Temporary URL that expires after 60 seconds for downloading the original image of the back of the document. Might be null if the back of the document was not collected. */
    public var originalBack: String?
    /** Temporary URL that expires after 60 seconds for downloading a cropped image containing just the front of the document. */
    public var croppedFront: String?
    /** Temporary URL that expires after 60 seconds for downloading a cropped image containing just the back of the document. Might be null if the back of the document was not collected. */
    public var croppedBack: String?
    /** Temporary URL that expires after 60 seconds for downloading a crop of just the user's face from the document image. Might be null if the document does not contain a face photo. */
    public var face: String?

    public init(originalFront: String?, originalBack: String?, croppedFront: String?, croppedBack: String?, face: String?) {
        self.originalFront = originalFront
        self.originalBack = originalBack
        self.croppedFront = croppedFront
        self.croppedBack = croppedBack
        self.face = face
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case originalFront = "original_front"
        case originalBack = "original_back"
        case croppedFront = "cropped_front"
        case croppedBack = "cropped_back"
        case face
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(originalFront, forKey: .originalFront)
        try container.encode(originalBack, forKey: .originalBack)
        try container.encode(croppedFront, forKey: .croppedFront)
        try container.encode(croppedBack, forKey: .croppedBack)
        try container.encode(face, forKey: .face)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        originalFront = try container.decodeIfPresent(String.self, forKey: .originalFront)
        originalBack = try container.decodeIfPresent(String.self, forKey: .originalBack)
        croppedFront = try container.decodeIfPresent(String.self, forKey: .croppedFront)
        croppedBack = try container.decodeIfPresent(String.self, forKey: .croppedBack)
        face = try container.decodeIfPresent(String.self, forKey: .face)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("original_front")
        nonAdditionalPropertyKeys.insert("original_back")
        nonAdditionalPropertyKeys.insert("cropped_front")
        nonAdditionalPropertyKeys.insert("cropped_back")
        nonAdditionalPropertyKeys.insert("face")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

