//
// IdentityMatchUser.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** The user&#39;s legal name, phone number, email address and address used to perform fuzzy match. If Financial Account Matching is enabled in the Identity Verification product, leave this field empty to automatically match against PII collected from the Identity Verification checks. */
public struct IdentityMatchUser: Codable, JSONEncodable, Hashable {

    /** The user's full legal name. */
    public var legalName: String?
    /** The user's phone number, in E.164 format: +{countrycode}{number}. For example: \"+14151234567\". Phone numbers provided in other formats will be parsed on a best-effort basis. */
    public var phoneNumber: String?
    /** The user's email address. */
    public var emailAddress: String?
    public var address: AddressDataNullableNoRequiredFields?

    public init(legalName: String? = nil, phoneNumber: String? = nil, emailAddress: String? = nil, address: AddressDataNullableNoRequiredFields? = nil) {
        self.legalName = legalName
        self.phoneNumber = phoneNumber
        self.emailAddress = emailAddress
        self.address = address
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case legalName = "legal_name"
        case phoneNumber = "phone_number"
        case emailAddress = "email_address"
        case address
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(legalName, forKey: .legalName)
        try container.encodeIfPresent(phoneNumber, forKey: .phoneNumber)
        try container.encodeIfPresent(emailAddress, forKey: .emailAddress)
        try container.encodeIfPresent(address, forKey: .address)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        legalName = try container.decodeIfPresent(String.self, forKey: .legalName)
        phoneNumber = try container.decodeIfPresent(String.self, forKey: .phoneNumber)
        emailAddress = try container.decodeIfPresent(String.self, forKey: .emailAddress)
        address = try container.decodeIfPresent(AddressDataNullableNoRequiredFields.self, forKey: .address)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("legal_name")
        nonAdditionalPropertyKeys.insert("phone_number")
        nonAdditionalPropertyKeys.insert("email_address")
        nonAdditionalPropertyKeys.insert("address")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

