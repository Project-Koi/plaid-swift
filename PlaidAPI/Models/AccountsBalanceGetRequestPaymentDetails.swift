//
// AccountsBalanceGetRequestPaymentDetails.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** An optional object containing payment details. If set, a payment risk assessment is performed and returned as AccountsBalanceGetResponsePaymentRiskAssessment. */
public struct AccountsBalanceGetRequestPaymentDetails: Codable, JSONEncodable, Hashable {

    static let clientTransactionIdRule = StringRule(minLength: 1, maxLength: 36, pattern: nil)
    static let balanceThresholdPercentageRule = NumericRule<Int>(minimum: 1, exclusiveMinimum: false, maximum: 100, exclusiveMaximum: false, multipleOf: nil)
    /** The Plaid `account_id` of the account that is the funding source for the proposed transaction. The `account_id` is returned in the `/accounts/get` endpoint as well as the [`onSuccess`](/docs/link/ios/#link-ios-onsuccess-linkSuccess-metadata-accounts-id) callback metadata.  This will return an [`INVALID_ACCOUNT_ID`](/docs/errors/invalid-input/#invalid_account_id) error if the account has been removed at the bank or if the `account_id` is no longer valid. */
    public var accountId: String?
    /** The unique ID that you would like to use to refer to this transaction. For your convenience mapping your internal data, you could use your internal identifier for this transaction. The max length for this field is 36 characters. */
    public var clientTransactionId: String?
    /** The transaction amount, in USD (e.g. `102.05`) */
    public var amount: Double?
    /** The threshold percentage of the account balance used for comparison with the requested ACH debit amount. */
    public var balanceThresholdPercentage: Int? = 90
    /** A boolean that determines whether the balance has to be refreshed in real time as part of the API call. */
    public var requiresRealTimeBalanceRefresh: Bool?

    public init(accountId: String? = nil, clientTransactionId: String? = nil, amount: Double? = nil, balanceThresholdPercentage: Int? = 90, requiresRealTimeBalanceRefresh: Bool? = nil) {
        self.accountId = accountId
        self.clientTransactionId = clientTransactionId
        self.amount = amount
        self.balanceThresholdPercentage = balanceThresholdPercentage
        self.requiresRealTimeBalanceRefresh = requiresRealTimeBalanceRefresh
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case accountId = "account_id"
        case clientTransactionId = "client_transaction_id"
        case amount
        case balanceThresholdPercentage = "balance_threshold_percentage"
        case requiresRealTimeBalanceRefresh = "requires_real_time_balance_refresh"
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(accountId, forKey: .accountId)
        try container.encodeIfPresent(clientTransactionId, forKey: .clientTransactionId)
        try container.encodeIfPresent(amount, forKey: .amount)
        try container.encodeIfPresent(balanceThresholdPercentage, forKey: .balanceThresholdPercentage)
        try container.encodeIfPresent(requiresRealTimeBalanceRefresh, forKey: .requiresRealTimeBalanceRefresh)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        accountId = try container.decodeIfPresent(String.self, forKey: .accountId)
        clientTransactionId = try container.decodeIfPresent(String.self, forKey: .clientTransactionId)
        amount = try container.decodeIfPresent(Double.self, forKey: .amount)
        balanceThresholdPercentage = try container.decodeIfPresent(Int.self, forKey: .balanceThresholdPercentage)
        requiresRealTimeBalanceRefresh = try container.decodeIfPresent(Bool.self, forKey: .requiresRealTimeBalanceRefresh)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("account_id")
        nonAdditionalPropertyKeys.insert("client_transaction_id")
        nonAdditionalPropertyKeys.insert("amount")
        nonAdditionalPropertyKeys.insert("balance_threshold_percentage")
        nonAdditionalPropertyKeys.insert("requires_real_time_balance_refresh")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

