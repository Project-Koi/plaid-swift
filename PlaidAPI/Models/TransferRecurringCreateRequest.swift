//
// TransferRecurringCreateRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Defines the request schema for &#x60;/transfer/recurring/create&#x60; */
public struct TransferRecurringCreateRequest: Codable, JSONEncodable, Hashable {

    static let idempotencyKeyRule = StringRule(minLength: nil, maxLength: 50, pattern: nil)
    /** Your Plaid API `client_id`. The `client_id` is required and may be provided either in the `PLAID-CLIENT-ID` header or as part of a request body. */
    public var clientId: String?
    /** Your Plaid API `secret`. The `secret` is required and may be provided either in the `PLAID-SECRET` header or as part of a request body. */
    public var secret: String?
    /** The Plaid `access_token` for the account that will be debited or credited. */
    public var accessToken: String
    /** A random key provided by the client, per unique recurring transfer. Maximum of 50 characters.  The API supports idempotency for safely retrying requests without accidentally performing the same operation twice. For example, if a request to create a recurring fails due to a network connection error, you can retry the request with the same idempotency key to guarantee that only a single recurring transfer is created. */
    public var idempotencyKey: String
    /** The Plaid `account_id` corresponding to the end-user account that will be debited or credited. */
    public var accountId: String
    /** Specify the account used to fund the transfer. Customers can find a list of `funding_account_id`s in the Accounts page of your Plaid Dashboard, under the \"Account ID\" column. If this field is left blank, it will default to the default `funding_account_id` specified during onboarding. */
    @available(*, deprecated, message: "This property is deprecated.")
    public var fundingAccountId: String?
    public var type: TransferType
    public var network: TransferRecurringNetwork
    public var achClass: ACHClass?
    /** The amount of the transfer (decimal string with two digits of precision e.g. \"10.00\"). When calling `/transfer/authorization/create`, specify the maximum amount to authorize. When calling `/transfer/create`, specify the exact amount of the transfer, up to a maximum of the amount authorized. If this field is left blank when calling `/transfer/create`, the maximum amount authorized in the `authorization_id` will be sent. */
    public var amount: String
    /** If the end user is initiating the specific transfer themselves via an interactive UI, this should be `true`; for automatic recurring payments where the end user is not actually initiating each individual transfer, it should be `false`. */
    public var userPresent: Bool?
    /** The currency of the transfer amount. The default value is \"USD\". */
    @available(*, deprecated, message: "This property is deprecated.")
    public var isoCurrencyCode: String?
    /** The description of the recurring transfer. */
    public var description: String
    /** Plaidâ€™s unique identifier for a test clock. This field may only be used when using `sandbox` environment. If provided, the created `recurring_transfer` is associated with the `test_clock`. New originations are automatically generated when the associated `test_clock` advances. */
    public var testClockId: String?
    public var schedule: TransferRecurringSchedule
    public var user: TransferUserInRequest
    public var device: TransferDevice?

    public init(clientId: String? = nil, secret: String? = nil, accessToken: String, idempotencyKey: String, accountId: String, fundingAccountId: String? = nil, type: TransferType, network: TransferRecurringNetwork, achClass: ACHClass? = nil, amount: String, userPresent: Bool? = nil, isoCurrencyCode: String? = nil, description: String, testClockId: String? = nil, schedule: TransferRecurringSchedule, user: TransferUserInRequest, device: TransferDevice? = nil) {
        self.clientId = clientId
        self.secret = secret
        self.accessToken = accessToken
        self.idempotencyKey = idempotencyKey
        self.accountId = accountId
        self.fundingAccountId = fundingAccountId
        self.type = type
        self.network = network
        self.achClass = achClass
        self.amount = amount
        self.userPresent = userPresent
        self.isoCurrencyCode = isoCurrencyCode
        self.description = description
        self.testClockId = testClockId
        self.schedule = schedule
        self.user = user
        self.device = device
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case clientId = "client_id"
        case secret
        case accessToken = "access_token"
        case idempotencyKey = "idempotency_key"
        case accountId = "account_id"
        case fundingAccountId = "funding_account_id"
        case type
        case network
        case achClass = "ach_class"
        case amount
        case userPresent = "user_present"
        case isoCurrencyCode = "iso_currency_code"
        case description
        case testClockId = "test_clock_id"
        case schedule
        case user
        case device
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(clientId, forKey: .clientId)
        try container.encodeIfPresent(secret, forKey: .secret)
        try container.encode(accessToken, forKey: .accessToken)
        try container.encode(idempotencyKey, forKey: .idempotencyKey)
        try container.encode(accountId, forKey: .accountId)
        try container.encodeIfPresent(fundingAccountId, forKey: .fundingAccountId)
        try container.encode(type, forKey: .type)
        try container.encode(network, forKey: .network)
        try container.encodeIfPresent(achClass, forKey: .achClass)
        try container.encode(amount, forKey: .amount)
        try container.encodeIfPresent(userPresent, forKey: .userPresent)
        try container.encodeIfPresent(isoCurrencyCode, forKey: .isoCurrencyCode)
        try container.encode(description, forKey: .description)
        try container.encodeIfPresent(testClockId, forKey: .testClockId)
        try container.encode(schedule, forKey: .schedule)
        try container.encode(user, forKey: .user)
        try container.encodeIfPresent(device, forKey: .device)
    }
}

