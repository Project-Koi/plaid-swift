//
// PaymentInitiationMetadata.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Metadata that captures what specific payment configurations an institution supports when making Payment Initiation requests. */
public struct PaymentInitiationMetadata: Codable, JSONEncodable, Hashable {

    /** Indicates whether the institution supports payments from a different country. */
    public var supportsInternationalPayments: Bool
    /** Indicates whether the institution supports SEPA Instant payments. */
    public var supportsSepaInstant: Bool
    /** A mapping of currency to maximum payment amount (denominated in the smallest unit of currency) supported by the institution.  Example: `{\"GBP\": \"10000\"}`  */
    public var maximumPaymentAmount: [String: String]
    /** Indicates whether the institution supports returning refund details when initiating a payment. */
    public var supportsRefundDetails: Bool
    public var standingOrderMetadata: PaymentInitiationStandingOrderMetadata?
    /** Indicates whether the institution supports payment consents. */
    public var supportsPaymentConsents: Bool

    public init(supportsInternationalPayments: Bool, supportsSepaInstant: Bool, maximumPaymentAmount: [String: String], supportsRefundDetails: Bool, standingOrderMetadata: PaymentInitiationStandingOrderMetadata?, supportsPaymentConsents: Bool) {
        self.supportsInternationalPayments = supportsInternationalPayments
        self.supportsSepaInstant = supportsSepaInstant
        self.maximumPaymentAmount = maximumPaymentAmount
        self.supportsRefundDetails = supportsRefundDetails
        self.standingOrderMetadata = standingOrderMetadata
        self.supportsPaymentConsents = supportsPaymentConsents
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case supportsInternationalPayments = "supports_international_payments"
        case supportsSepaInstant = "supports_sepa_instant"
        case maximumPaymentAmount = "maximum_payment_amount"
        case supportsRefundDetails = "supports_refund_details"
        case standingOrderMetadata = "standing_order_metadata"
        case supportsPaymentConsents = "supports_payment_consents"
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(supportsInternationalPayments, forKey: .supportsInternationalPayments)
        try container.encode(supportsSepaInstant, forKey: .supportsSepaInstant)
        try container.encode(maximumPaymentAmount, forKey: .maximumPaymentAmount)
        try container.encode(supportsRefundDetails, forKey: .supportsRefundDetails)
        try container.encode(standingOrderMetadata, forKey: .standingOrderMetadata)
        try container.encode(supportsPaymentConsents, forKey: .supportsPaymentConsents)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        supportsInternationalPayments = try container.decode(Bool.self, forKey: .supportsInternationalPayments)
        supportsSepaInstant = try container.decode(Bool.self, forKey: .supportsSepaInstant)
        maximumPaymentAmount = try container.decode([String: String].self, forKey: .maximumPaymentAmount)
        supportsRefundDetails = try container.decode(Bool.self, forKey: .supportsRefundDetails)
        standingOrderMetadata = try container.decodeIfPresent(PaymentInitiationStandingOrderMetadata.self, forKey: .standingOrderMetadata)
        supportsPaymentConsents = try container.decode(Bool.self, forKey: .supportsPaymentConsents)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("supports_international_payments")
        nonAdditionalPropertyKeys.insert("supports_sepa_instant")
        nonAdditionalPropertyKeys.insert("maximum_payment_amount")
        nonAdditionalPropertyKeys.insert("supports_refund_details")
        nonAdditionalPropertyKeys.insert("standing_order_metadata")
        nonAdditionalPropertyKeys.insert("supports_payment_consents")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

