//
// TransferLedgerDistributeRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Defines the request schema for &#x60;/transfer/ledger/distribute&#x60; */
public struct TransferLedgerDistributeRequest: Codable, JSONEncodable, Hashable {

    static let idempotencyKeyRule = StringRule(minLength: nil, maxLength: 50, pattern: nil)
    /** Your Plaid API `client_id`. The `client_id` is required and may be provided either in the `PLAID-CLIENT-ID` header or as part of a request body. */
    public var clientId: String?
    /** Your Plaid API `secret`. The `secret` is required and may be provided either in the `PLAID-SECRET` header or as part of a request body. */
    public var secret: String?
    /** The client to pull money from. Must be the platform itself or its originator. One of `from_client_id` and `to_client_id` must be the platform's `client_id`. */
    public var fromClientId: String
    /** The client to credit money to. Must be the platform itself or its originator. One of `from_client_id` and `to_client_id` must be the platform's `client_id`. */
    public var toClientId: String
    /** The amount to move (decimal string with two digits of precision e.g. \"10.00\"). Amount must be positive. */
    public var amount: String
    /** A unique key provided by the client, per unique ledger distribute. Maximum of 50 characters.  The API supports idempotency for safely retrying the request without accidentally performing the same operation twice. For example, if a request to create a ledger distribute fails due to a network connection error, you can retry the request with the same idempotency key to guarantee that only a single distribute is created. */
    public var idempotencyKey: String
    /** An optional description for the ledger distribute operation. */
    public var description: String?

    public init(clientId: String? = nil, secret: String? = nil, fromClientId: String, toClientId: String, amount: String, idempotencyKey: String, description: String? = nil) {
        self.clientId = clientId
        self.secret = secret
        self.fromClientId = fromClientId
        self.toClientId = toClientId
        self.amount = amount
        self.idempotencyKey = idempotencyKey
        self.description = description
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case clientId = "client_id"
        case secret
        case fromClientId = "from_client_id"
        case toClientId = "to_client_id"
        case amount
        case idempotencyKey = "idempotency_key"
        case description
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(clientId, forKey: .clientId)
        try container.encodeIfPresent(secret, forKey: .secret)
        try container.encode(fromClientId, forKey: .fromClientId)
        try container.encode(toClientId, forKey: .toClientId)
        try container.encode(amount, forKey: .amount)
        try container.encode(idempotencyKey, forKey: .idempotencyKey)
        try container.encodeIfPresent(description, forKey: .description)
    }
}

