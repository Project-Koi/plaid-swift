//
// NameMatchScore.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Score found by matching name provided by the API with the name on the account at the financial institution. If the account contains multiple owners, the maximum match score is filled. */
public struct NameMatchScore: Codable, JSONEncodable, Hashable {

    /** Match score for name. 100 is a perfect score, 99-85 means a strong match, 84-70 is a partial match, any score less than 70 is a mismatch. Typically, the match threshold should be set to a score of 70 or higher. If the name is missing from either the API or financial institution, this is null. */
    public var score: Int?
    /** first or last name completely matched, likely a family member */
    public var isFirstNameOrLastNameMatch: Bool?
    /** nickname matched, example Jennifer and Jenn. */
    public var isNicknameMatch: Bool?
    /** Is `true` if the name on either of the names that was matched for the score contained strings indicative of a business name, such as \"CORP\", \"LLC\", \"INC\", or \"LTD\". A `true` result generally indicates the entity is a business. However, a `false` result does not mean the entity is not a business, as some businesses do not use these strings in the names used for their financial institution accounts. */
    @available(*, deprecated, message: "This property is deprecated.")
    public var isBusinessNameDetected: Bool?

    public init(score: Int? = nil, isFirstNameOrLastNameMatch: Bool? = nil, isNicknameMatch: Bool? = nil, isBusinessNameDetected: Bool? = nil) {
        self.score = score
        self.isFirstNameOrLastNameMatch = isFirstNameOrLastNameMatch
        self.isNicknameMatch = isNicknameMatch
        self.isBusinessNameDetected = isBusinessNameDetected
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case score
        case isFirstNameOrLastNameMatch = "is_first_name_or_last_name_match"
        case isNicknameMatch = "is_nickname_match"
        case isBusinessNameDetected = "is_business_name_detected"
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(score, forKey: .score)
        try container.encodeIfPresent(isFirstNameOrLastNameMatch, forKey: .isFirstNameOrLastNameMatch)
        try container.encodeIfPresent(isNicknameMatch, forKey: .isNicknameMatch)
        try container.encodeIfPresent(isBusinessNameDetected, forKey: .isBusinessNameDetected)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        score = try container.decodeIfPresent(Int.self, forKey: .score)
        isFirstNameOrLastNameMatch = try container.decodeIfPresent(Bool.self, forKey: .isFirstNameOrLastNameMatch)
        isNicknameMatch = try container.decodeIfPresent(Bool.self, forKey: .isNicknameMatch)
        isBusinessNameDetected = try container.decodeIfPresent(Bool.self, forKey: .isBusinessNameDetected)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("score")
        nonAdditionalPropertyKeys.insert("is_first_name_or_last_name_match")
        nonAdditionalPropertyKeys.insert("is_nickname_match")
        nonAdditionalPropertyKeys.insert("is_business_name_detected")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

