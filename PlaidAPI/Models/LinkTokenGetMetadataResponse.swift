//
// LinkTokenGetMetadataResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** An object specifying the arguments originally provided to the &#x60;/link/token/create&#x60; call. */
public struct LinkTokenGetMetadataResponse: Codable, JSONEncodable, Hashable {

    /** The `products` specified in the `/link/token/create` call. */
    public var initialProducts: [Products]
    /** The `webhook` specified in the `/link/token/create` call. */
    public var webhook: String?
    /** The `country_codes` specified in the `/link/token/create` call. */
    public var countryCodes: [CountryCode]
    /** The `language` specified in the `/link/token/create` call. */
    public var language: String?
    public var institutionData: LinkTokenCreateInstitutionData?
    public var accountFilters: AccountFiltersResponse?
    /** The `redirect_uri` specified in the `/link/token/create` call. */
    public var redirectUri: String?
    /** The `client_name` specified in the `/link/token/create` call. */
    public var clientName: String?
    /** The user token associated with the User data is being requested for. */
    public var userToken: String?

    public init(initialProducts: [Products], webhook: String?, countryCodes: [CountryCode], language: String?, institutionData: LinkTokenCreateInstitutionData? = nil, accountFilters: AccountFiltersResponse? = nil, redirectUri: String?, clientName: String?, userToken: String? = nil) {
        self.initialProducts = initialProducts
        self.webhook = webhook
        self.countryCodes = countryCodes
        self.language = language
        self.institutionData = institutionData
        self.accountFilters = accountFilters
        self.redirectUri = redirectUri
        self.clientName = clientName
        self.userToken = userToken
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case initialProducts = "initial_products"
        case webhook
        case countryCodes = "country_codes"
        case language
        case institutionData = "institution_data"
        case accountFilters = "account_filters"
        case redirectUri = "redirect_uri"
        case clientName = "client_name"
        case userToken = "user_token"
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(initialProducts, forKey: .initialProducts)
        try container.encode(webhook, forKey: .webhook)
        try container.encode(countryCodes, forKey: .countryCodes)
        try container.encode(language, forKey: .language)
        try container.encodeIfPresent(institutionData, forKey: .institutionData)
        try container.encodeIfPresent(accountFilters, forKey: .accountFilters)
        try container.encode(redirectUri, forKey: .redirectUri)
        try container.encode(clientName, forKey: .clientName)
        try container.encodeIfPresent(userToken, forKey: .userToken)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        initialProducts = try container.decode([Products].self, forKey: .initialProducts)
        webhook = try container.decodeIfPresent(String.self, forKey: .webhook)
        countryCodes = try container.decode([CountryCode].self, forKey: .countryCodes)
        language = try container.decodeIfPresent(String.self, forKey: .language)
        institutionData = try container.decodeIfPresent(LinkTokenCreateInstitutionData.self, forKey: .institutionData)
        accountFilters = try container.decodeIfPresent(AccountFiltersResponse.self, forKey: .accountFilters)
        redirectUri = try container.decodeIfPresent(String.self, forKey: .redirectUri)
        clientName = try container.decodeIfPresent(String.self, forKey: .clientName)
        userToken = try container.decodeIfPresent(String.self, forKey: .userToken)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("initial_products")
        nonAdditionalPropertyKeys.insert("webhook")
        nonAdditionalPropertyKeys.insert("country_codes")
        nonAdditionalPropertyKeys.insert("language")
        nonAdditionalPropertyKeys.insert("institution_data")
        nonAdditionalPropertyKeys.insert("account_filters")
        nonAdditionalPropertyKeys.insert("redirect_uri")
        nonAdditionalPropertyKeys.insert("client_name")
        nonAdditionalPropertyKeys.insert("user_token")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

