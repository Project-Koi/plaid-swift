//
// ClientProvidedTransactionLocation.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** A representation of where a transaction took place.  Use this field to pass in structured location information you may have about your transactions. Providing location data is optional but can increase result quality. If you have unstructured location information, it may be appended to the &#x60;description&#x60; field. */
public struct ClientProvidedTransactionLocation: Codable, JSONEncodable, Hashable {

    /** The country where the transaction occurred. */
    public var country: String?
    /** The region or state where the transaction occurred. */
    public var region: String?
    /** The city where the transaction occurred. */
    public var city: String?
    /** The street address where the transaction occurred. */
    public var address: String?
    /** The postal code where the transaction occurred. */
    public var postalCode: String?

    public init(country: String? = nil, region: String? = nil, city: String? = nil, address: String? = nil, postalCode: String? = nil) {
        self.country = country
        self.region = region
        self.city = city
        self.address = address
        self.postalCode = postalCode
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case country
        case region
        case city
        case address
        case postalCode = "postal_code"
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(country, forKey: .country)
        try container.encodeIfPresent(region, forKey: .region)
        try container.encodeIfPresent(city, forKey: .city)
        try container.encodeIfPresent(address, forKey: .address)
        try container.encodeIfPresent(postalCode, forKey: .postalCode)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        country = try container.decodeIfPresent(String.self, forKey: .country)
        region = try container.decodeIfPresent(String.self, forKey: .region)
        city = try container.decodeIfPresent(String.self, forKey: .city)
        address = try container.decodeIfPresent(String.self, forKey: .address)
        postalCode = try container.decodeIfPresent(String.self, forKey: .postalCode)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("country")
        nonAdditionalPropertyKeys.insert("region")
        nonAdditionalPropertyKeys.insert("city")
        nonAdditionalPropertyKeys.insert("address")
        nonAdditionalPropertyKeys.insert("postal_code")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

