//
// SimulatedTransferSweep.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** A sweep returned from the &#x60;/sandbox/transfer/sweep/simulate&#x60; endpoint. Can be null if there are no transfers to include in a sweep. */
public struct SimulatedTransferSweep: Codable, JSONEncodable, Hashable {

    /** Identifier of the sweep. */
    public var id: String
    /** The id of the funding account to use, available in the Plaid Dashboard. This determines which of your business checking accounts will be credited or debited. */
    public var fundingAccountId: String
    /** The datetime when the sweep occurred, in RFC 3339 format. */
    public var created: Date
    /** Signed decimal amount of the sweep as it appears on your sweep account ledger (e.g. \"-10.00\")  If amount is not present, the sweep was net-settled to zero and outstanding debits and credits between the sweep account and Plaid are balanced. */
    public var amount: String
    /** The currency of the sweep, e.g. \"USD\". */
    public var isoCurrencyCode: String
    /** The date when the sweep settled, in the YYYY-MM-DD format. */
    public var settled: Date?
    public var status: SweepStatus?
    public var trigger: SweepTrigger?
    /** The description of the deposit that will be passed to the receiving bank (up to 10 characters). Note that banks utilize this field differently, and may or may not show it on the bank statement. */
    public var description: String?
    /** The trace identifier for the transfer based on its network. This will only be set after the transfer has posted.  For `ach` or `same-day-ach` transfers, this is the ACH trace number. For `rtp` transfers, this is the Transaction Identification number. For `wire` transfers, this is the IMAD (Input Message Accountability Data) number. */
    public var networkTraceId: String?

    public init(id: String, fundingAccountId: String, created: Date, amount: String, isoCurrencyCode: String, settled: Date?, status: SweepStatus? = nil, trigger: SweepTrigger? = nil, description: String? = nil, networkTraceId: String? = nil) {
        self.id = id
        self.fundingAccountId = fundingAccountId
        self.created = created
        self.amount = amount
        self.isoCurrencyCode = isoCurrencyCode
        self.settled = settled
        self.status = status
        self.trigger = trigger
        self.description = description
        self.networkTraceId = networkTraceId
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case fundingAccountId = "funding_account_id"
        case created
        case amount
        case isoCurrencyCode = "iso_currency_code"
        case settled
        case status
        case trigger
        case description
        case networkTraceId = "network_trace_id"
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(fundingAccountId, forKey: .fundingAccountId)
        try container.encode(created, forKey: .created)
        try container.encode(amount, forKey: .amount)
        try container.encode(isoCurrencyCode, forKey: .isoCurrencyCode)
        try container.encode(settled, forKey: .settled)
        try container.encodeIfPresent(status, forKey: .status)
        try container.encodeIfPresent(trigger, forKey: .trigger)
        try container.encodeIfPresent(description, forKey: .description)
        try container.encodeIfPresent(networkTraceId, forKey: .networkTraceId)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        id = try container.decode(String.self, forKey: .id)
        fundingAccountId = try container.decode(String.self, forKey: .fundingAccountId)
        created = try container.decode(Date.self, forKey: .created)
        amount = try container.decode(String.self, forKey: .amount)
        isoCurrencyCode = try container.decode(String.self, forKey: .isoCurrencyCode)
        settled = try container.decodeIfPresent(Date.self, forKey: .settled)
        status = try container.decodeIfPresent(SweepStatus.self, forKey: .status)
        trigger = try container.decodeIfPresent(SweepTrigger.self, forKey: .trigger)
        description = try container.decodeIfPresent(String.self, forKey: .description)
        networkTraceId = try container.decodeIfPresent(String.self, forKey: .networkTraceId)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("id")
        nonAdditionalPropertyKeys.insert("funding_account_id")
        nonAdditionalPropertyKeys.insert("created")
        nonAdditionalPropertyKeys.insert("amount")
        nonAdditionalPropertyKeys.insert("iso_currency_code")
        nonAdditionalPropertyKeys.insert("settled")
        nonAdditionalPropertyKeys.insert("status")
        nonAdditionalPropertyKeys.insert("trigger")
        nonAdditionalPropertyKeys.insert("description")
        nonAdditionalPropertyKeys.insert("network_trace_id")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

