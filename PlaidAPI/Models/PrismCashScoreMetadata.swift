//
// PrismCashScoreMetadata.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** An object containing metadata about the provided transactions. */
public struct PrismCashScoreMetadata: Codable, JSONEncodable, Hashable {

    /** Number of days since the oldest transaction. */
    public var maxAge: Int?
    /** Number of days since the latest transaction. */
    public var minAge: Int?
    /** Number of days since the latest credit transaction. */
    public var minAgeCredit: Int?
    /** Number of days since the latest debit transaction. */
    public var minAgeDebit: Int?
    /** Number of days since the oldest debit transaction. */
    public var maxAgeDebit: Int?
    /** Number of days since the oldest credit transaction. */
    public var maxAgeCredit: Int?
    /** Number of credit transactions. */
    public var numTrxnCredit: Int?
    /** Number of debit transactions. */
    public var numTrxnDebit: Int?
    /** Number of credit transactions in the last 30 days. */
    public var l1mCreditValueCnt: Int?
    /** Number of debit transactions in the last 30 days. */
    public var l1mDebitValueCnt: Int?

    public init(maxAge: Int?, minAge: Int?, minAgeCredit: Int?, minAgeDebit: Int?, maxAgeDebit: Int?, maxAgeCredit: Int?, numTrxnCredit: Int?, numTrxnDebit: Int?, l1mCreditValueCnt: Int?, l1mDebitValueCnt: Int?) {
        self.maxAge = maxAge
        self.minAge = minAge
        self.minAgeCredit = minAgeCredit
        self.minAgeDebit = minAgeDebit
        self.maxAgeDebit = maxAgeDebit
        self.maxAgeCredit = maxAgeCredit
        self.numTrxnCredit = numTrxnCredit
        self.numTrxnDebit = numTrxnDebit
        self.l1mCreditValueCnt = l1mCreditValueCnt
        self.l1mDebitValueCnt = l1mDebitValueCnt
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case maxAge = "max_age"
        case minAge = "min_age"
        case minAgeCredit = "min_age_credit"
        case minAgeDebit = "min_age_debit"
        case maxAgeDebit = "max_age_debit"
        case maxAgeCredit = "max_age_credit"
        case numTrxnCredit = "num_trxn_credit"
        case numTrxnDebit = "num_trxn_debit"
        case l1mCreditValueCnt = "l1m_credit_value_cnt"
        case l1mDebitValueCnt = "l1m_debit_value_cnt"
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(maxAge, forKey: .maxAge)
        try container.encode(minAge, forKey: .minAge)
        try container.encode(minAgeCredit, forKey: .minAgeCredit)
        try container.encode(minAgeDebit, forKey: .minAgeDebit)
        try container.encode(maxAgeDebit, forKey: .maxAgeDebit)
        try container.encode(maxAgeCredit, forKey: .maxAgeCredit)
        try container.encode(numTrxnCredit, forKey: .numTrxnCredit)
        try container.encode(numTrxnDebit, forKey: .numTrxnDebit)
        try container.encode(l1mCreditValueCnt, forKey: .l1mCreditValueCnt)
        try container.encode(l1mDebitValueCnt, forKey: .l1mDebitValueCnt)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        maxAge = try container.decodeIfPresent(Int.self, forKey: .maxAge)
        minAge = try container.decodeIfPresent(Int.self, forKey: .minAge)
        minAgeCredit = try container.decodeIfPresent(Int.self, forKey: .minAgeCredit)
        minAgeDebit = try container.decodeIfPresent(Int.self, forKey: .minAgeDebit)
        maxAgeDebit = try container.decodeIfPresent(Int.self, forKey: .maxAgeDebit)
        maxAgeCredit = try container.decodeIfPresent(Int.self, forKey: .maxAgeCredit)
        numTrxnCredit = try container.decodeIfPresent(Int.self, forKey: .numTrxnCredit)
        numTrxnDebit = try container.decodeIfPresent(Int.self, forKey: .numTrxnDebit)
        l1mCreditValueCnt = try container.decodeIfPresent(Int.self, forKey: .l1mCreditValueCnt)
        l1mDebitValueCnt = try container.decodeIfPresent(Int.self, forKey: .l1mDebitValueCnt)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("max_age")
        nonAdditionalPropertyKeys.insert("min_age")
        nonAdditionalPropertyKeys.insert("min_age_credit")
        nonAdditionalPropertyKeys.insert("min_age_debit")
        nonAdditionalPropertyKeys.insert("max_age_debit")
        nonAdditionalPropertyKeys.insert("max_age_credit")
        nonAdditionalPropertyKeys.insert("num_trxn_credit")
        nonAdditionalPropertyKeys.insert("num_trxn_debit")
        nonAdditionalPropertyKeys.insert("l1m_credit_value_cnt")
        nonAdditionalPropertyKeys.insert("l1m_debit_value_cnt")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

