//
// InvestmentTransaction.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** A transaction within an investment account. */
public struct InvestmentTransaction: Codable, JSONEncodable, Hashable {

    /** The ID of the Investment transaction, unique across all Plaid transactions. Like all Plaid identifiers, the `investment_transaction_id` is case sensitive. */
    public var investmentTransactionId: String
    /** A legacy field formerly used internally by Plaid to identify certain canceled transactions. */
    @available(*, deprecated, message: "This property is deprecated.")
    public var cancelTransactionId: String?
    /** The `account_id` of the account against which this transaction posted. */
    public var accountId: String
    /** The `security_id` to which this transaction is related. */
    public var securityId: String?
    /** The [ISO 8601](https://wikipedia.org/wiki/ISO_8601) posting date for the transaction. */
    public var date: Date
    /** The institutionâ€™s description of the transaction. */
    public var name: String
    /** The number of units of the security involved in this transaction. Positive for buy transactions; negative for sell transactions. */
    public var quantity: Double
    /** The complete value of the transaction. Positive values when cash is debited, e.g. purchases of stock; negative values when cash is credited, e.g. sales of stock. Treatment remains the same for cash-only movements unassociated with securities. */
    public var amount: Double
    /** The price of the security at which this transaction occurred. */
    public var price: Double
    /** The combined value of all fees applied to this transaction */
    public var fees: Double?
    public var type: InvestmentTransactionType
    public var subtype: InvestmentTransactionSubtype
    /** The ISO-4217 currency code of the transaction. Always `null` if `unofficial_currency_code` is non-`null`. */
    public var isoCurrencyCode: String?
    /** The unofficial currency code associated with the holding. Always `null` if `iso_currency_code` is non-`null`. Unofficial currency codes are used for currencies that do not have official ISO currency codes, such as cryptocurrencies and the currencies of certain countries.  See the [currency code schema](https://plaid.com/docs/api/accounts#currency-code-schema) for a full listing of supported `iso_currency_code`s. */
    public var unofficialCurrencyCode: String?

    public init(investmentTransactionId: String, cancelTransactionId: String? = nil, accountId: String, securityId: String?, date: Date, name: String, quantity: Double, amount: Double, price: Double, fees: Double?, type: InvestmentTransactionType, subtype: InvestmentTransactionSubtype, isoCurrencyCode: String?, unofficialCurrencyCode: String?) {
        self.investmentTransactionId = investmentTransactionId
        self.cancelTransactionId = cancelTransactionId
        self.accountId = accountId
        self.securityId = securityId
        self.date = date
        self.name = name
        self.quantity = quantity
        self.amount = amount
        self.price = price
        self.fees = fees
        self.type = type
        self.subtype = subtype
        self.isoCurrencyCode = isoCurrencyCode
        self.unofficialCurrencyCode = unofficialCurrencyCode
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case investmentTransactionId = "investment_transaction_id"
        case cancelTransactionId = "cancel_transaction_id"
        case accountId = "account_id"
        case securityId = "security_id"
        case date
        case name
        case quantity
        case amount
        case price
        case fees
        case type
        case subtype
        case isoCurrencyCode = "iso_currency_code"
        case unofficialCurrencyCode = "unofficial_currency_code"
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(investmentTransactionId, forKey: .investmentTransactionId)
        try container.encodeIfPresent(cancelTransactionId, forKey: .cancelTransactionId)
        try container.encode(accountId, forKey: .accountId)
        try container.encode(securityId, forKey: .securityId)
        try container.encode(date, forKey: .date)
        try container.encode(name, forKey: .name)
        try container.encode(quantity, forKey: .quantity)
        try container.encode(amount, forKey: .amount)
        try container.encode(price, forKey: .price)
        try container.encode(fees, forKey: .fees)
        try container.encode(type, forKey: .type)
        try container.encode(subtype, forKey: .subtype)
        try container.encode(isoCurrencyCode, forKey: .isoCurrencyCode)
        try container.encode(unofficialCurrencyCode, forKey: .unofficialCurrencyCode)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        investmentTransactionId = try container.decode(String.self, forKey: .investmentTransactionId)
        cancelTransactionId = try container.decodeIfPresent(String.self, forKey: .cancelTransactionId)
        accountId = try container.decode(String.self, forKey: .accountId)
        securityId = try container.decodeIfPresent(String.self, forKey: .securityId)
        date = try container.decode(Date.self, forKey: .date)
        name = try container.decode(String.self, forKey: .name)
        quantity = try container.decode(Double.self, forKey: .quantity)
        amount = try container.decode(Double.self, forKey: .amount)
        price = try container.decode(Double.self, forKey: .price)
        fees = try container.decodeIfPresent(Double.self, forKey: .fees)
        type = try container.decode(InvestmentTransactionType.self, forKey: .type)
        subtype = try container.decode(InvestmentTransactionSubtype.self, forKey: .subtype)
        isoCurrencyCode = try container.decodeIfPresent(String.self, forKey: .isoCurrencyCode)
        unofficialCurrencyCode = try container.decodeIfPresent(String.self, forKey: .unofficialCurrencyCode)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("investment_transaction_id")
        nonAdditionalPropertyKeys.insert("cancel_transaction_id")
        nonAdditionalPropertyKeys.insert("account_id")
        nonAdditionalPropertyKeys.insert("security_id")
        nonAdditionalPropertyKeys.insert("date")
        nonAdditionalPropertyKeys.insert("name")
        nonAdditionalPropertyKeys.insert("quantity")
        nonAdditionalPropertyKeys.insert("amount")
        nonAdditionalPropertyKeys.insert("price")
        nonAdditionalPropertyKeys.insert("fees")
        nonAdditionalPropertyKeys.insert("type")
        nonAdditionalPropertyKeys.insert("subtype")
        nonAdditionalPropertyKeys.insert("iso_currency_code")
        nonAdditionalPropertyKeys.insert("unofficial_currency_code")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

