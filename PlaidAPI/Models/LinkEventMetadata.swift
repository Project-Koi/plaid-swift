//
// LinkEventMetadata.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Metadata about an event that occured while the user was going through Link */
public struct LinkEventMetadata: Codable, JSONEncodable, Hashable {

    /** The error code that the user encountered. Emitted by `ERROR`, `EXIT`. */
    public var errorCode: String?
    /** The error message that the user encountered. Emitted by: `ERROR`, `EXIT`. */
    public var errorMessage: String?
    /** The error type that the user encountered. Emitted by: `ERROR`, `EXIT`. */
    public var errorType: String?
    /** The status key indicates the point at which the user exited the Link flow. Emitted by: `EXIT`. */
    public var exitStatus: String?
    /** The ID of the selected institution. Emitted by: all events. */
    public var institutionId: String?
    /** The name of the selected institution. Emitted by: all events. */
    public var institutionName: String?
    /** The query used to search for institutions. Emitted by: `SEARCH_INSTITUTION`. */
    public var institutionSearchQuery: String?
    /** The request ID for the last request made by Link. This can be shared with Plaid Support to expedite investigation. Emitted by: all events. */
    public var requestId: String
    /** If set, the user has encountered one of the following MFA types: code, device, questions, selections. Emitted by: `SUBMIT_MFA` and `TRANSITION_VIEW` when view_name is `MFA`. */
    public var mfaType: String?
    /** The name of the view that is being transitioned to. Emitted by: `TRANSITION_VIEW`. */
    public var viewName: String?
    /** Either the verification method for a matched institution selected by the user or the Auth Type Select flow type selected by the user. If selection is used to describe selected verification method, then possible values are `phoneotp` or `password`;  if selection is used to describe the selected Auth Type Select flow, then possible values are `flow_type_manual` or `flow_type_instant`. Emitted by: `MATCHED_SELECT_VERIFY_METHOD` and `SELECT_AUTH_TYPE`. */
    public var selection: String?
    /** The name of the selected brand. */
    public var brandName: String?
    /** The reason this institution was matched, which will be either `returning_user` or `routing_number`. Emitted by: `MATCHED_SELECT_INSTITUTION`. */
    public var matchReason: String?
    /** The routing number submitted by user at the micro-deposits routing number pane. Emitted by `SUBMIT_ROUTING_NUMBER`. */
    public var routingNumber: String?
    /** The account number mask extracted from the user-provided account number. If the user-inputted account number is four digits long, `account_number_mask` is empty. Emitted by `SUBMIT_ACCOUNT_NUMBER`. */
    public var accountNumberMask: String?

    public init(errorCode: String? = nil, errorMessage: String? = nil, errorType: String? = nil, exitStatus: String? = nil, institutionId: String? = nil, institutionName: String? = nil, institutionSearchQuery: String? = nil, requestId: String, mfaType: String? = nil, viewName: String? = nil, selection: String? = nil, brandName: String? = nil, matchReason: String? = nil, routingNumber: String? = nil, accountNumberMask: String? = nil) {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.errorType = errorType
        self.exitStatus = exitStatus
        self.institutionId = institutionId
        self.institutionName = institutionName
        self.institutionSearchQuery = institutionSearchQuery
        self.requestId = requestId
        self.mfaType = mfaType
        self.viewName = viewName
        self.selection = selection
        self.brandName = brandName
        self.matchReason = matchReason
        self.routingNumber = routingNumber
        self.accountNumberMask = accountNumberMask
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case errorCode = "error_code"
        case errorMessage = "error_message"
        case errorType = "error_type"
        case exitStatus = "exit_status"
        case institutionId = "institution_id"
        case institutionName = "institution_name"
        case institutionSearchQuery = "institution_search_query"
        case requestId = "request_id"
        case mfaType = "mfa_type"
        case viewName = "view_name"
        case selection
        case brandName = "brand_name"
        case matchReason = "match_reason"
        case routingNumber = "routing_number"
        case accountNumberMask = "account_number_mask"
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(errorCode, forKey: .errorCode)
        try container.encodeIfPresent(errorMessage, forKey: .errorMessage)
        try container.encodeIfPresent(errorType, forKey: .errorType)
        try container.encodeIfPresent(exitStatus, forKey: .exitStatus)
        try container.encodeIfPresent(institutionId, forKey: .institutionId)
        try container.encodeIfPresent(institutionName, forKey: .institutionName)
        try container.encodeIfPresent(institutionSearchQuery, forKey: .institutionSearchQuery)
        try container.encode(requestId, forKey: .requestId)
        try container.encodeIfPresent(mfaType, forKey: .mfaType)
        try container.encodeIfPresent(viewName, forKey: .viewName)
        try container.encodeIfPresent(selection, forKey: .selection)
        try container.encodeIfPresent(brandName, forKey: .brandName)
        try container.encodeIfPresent(matchReason, forKey: .matchReason)
        try container.encodeIfPresent(routingNumber, forKey: .routingNumber)
        try container.encodeIfPresent(accountNumberMask, forKey: .accountNumberMask)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        errorCode = try container.decodeIfPresent(String.self, forKey: .errorCode)
        errorMessage = try container.decodeIfPresent(String.self, forKey: .errorMessage)
        errorType = try container.decodeIfPresent(String.self, forKey: .errorType)
        exitStatus = try container.decodeIfPresent(String.self, forKey: .exitStatus)
        institutionId = try container.decodeIfPresent(String.self, forKey: .institutionId)
        institutionName = try container.decodeIfPresent(String.self, forKey: .institutionName)
        institutionSearchQuery = try container.decodeIfPresent(String.self, forKey: .institutionSearchQuery)
        requestId = try container.decode(String.self, forKey: .requestId)
        mfaType = try container.decodeIfPresent(String.self, forKey: .mfaType)
        viewName = try container.decodeIfPresent(String.self, forKey: .viewName)
        selection = try container.decodeIfPresent(String.self, forKey: .selection)
        brandName = try container.decodeIfPresent(String.self, forKey: .brandName)
        matchReason = try container.decodeIfPresent(String.self, forKey: .matchReason)
        routingNumber = try container.decodeIfPresent(String.self, forKey: .routingNumber)
        accountNumberMask = try container.decodeIfPresent(String.self, forKey: .accountNumberMask)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("error_code")
        nonAdditionalPropertyKeys.insert("error_message")
        nonAdditionalPropertyKeys.insert("error_type")
        nonAdditionalPropertyKeys.insert("exit_status")
        nonAdditionalPropertyKeys.insert("institution_id")
        nonAdditionalPropertyKeys.insert("institution_name")
        nonAdditionalPropertyKeys.insert("institution_search_query")
        nonAdditionalPropertyKeys.insert("request_id")
        nonAdditionalPropertyKeys.insert("mfa_type")
        nonAdditionalPropertyKeys.insert("view_name")
        nonAdditionalPropertyKeys.insert("selection")
        nonAdditionalPropertyKeys.insert("brand_name")
        nonAdditionalPropertyKeys.insert("match_reason")
        nonAdditionalPropertyKeys.insert("routing_number")
        nonAdditionalPropertyKeys.insert("account_number_mask")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

