//
// BeaconReport.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** A Beacon Report describes the type of fraud committed by a user as well as the date the fraud was committed and the total amount of money lost due to the fraud incident.  This information is used to block similar fraud attempts on your platform as well as alert other companies who screen a user with matching identity information. Other companies will not receive any new identity information, just what matched, plus information such as industry, type of fraud, and date of fraud.  You can manage your fraud reports by adding, deleting, or editing reports as you get additional information on fraudulent users. */
public struct BeaconReport: Codable, JSONEncodable, Hashable {

    /** ID of the associated Beacon Report. */
    public var id: String
    /** ID of the associated Beacon User. */
    public var beaconUserId: String
    /** An ISO8601 formatted timestamp. */
    public var createdAt: Date
    public var type: BeaconReportType
    /** A date in the format YYYY-MM-DD (RFC 3339 Section 5.6). */
    public var fraudDate: Date
    public var fraudAmount: FraudAmount?
    public var auditTrail: BeaconAuditTrail

    public init(id: String, beaconUserId: String, createdAt: Date, type: BeaconReportType, fraudDate: Date, fraudAmount: FraudAmount?, auditTrail: BeaconAuditTrail) {
        self.id = id
        self.beaconUserId = beaconUserId
        self.createdAt = createdAt
        self.type = type
        self.fraudDate = fraudDate
        self.fraudAmount = fraudAmount
        self.auditTrail = auditTrail
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case beaconUserId = "beacon_user_id"
        case createdAt = "created_at"
        case type
        case fraudDate = "fraud_date"
        case fraudAmount = "fraud_amount"
        case auditTrail = "audit_trail"
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(beaconUserId, forKey: .beaconUserId)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encode(type, forKey: .type)
        try container.encode(fraudDate, forKey: .fraudDate)
        try container.encode(fraudAmount, forKey: .fraudAmount)
        try container.encode(auditTrail, forKey: .auditTrail)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        id = try container.decode(String.self, forKey: .id)
        beaconUserId = try container.decode(String.self, forKey: .beaconUserId)
        createdAt = try container.decode(Date.self, forKey: .createdAt)
        type = try container.decode(BeaconReportType.self, forKey: .type)
        fraudDate = try container.decode(Date.self, forKey: .fraudDate)
        fraudAmount = try container.decodeIfPresent(FraudAmount.self, forKey: .fraudAmount)
        auditTrail = try container.decode(BeaconAuditTrail.self, forKey: .auditTrail)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("id")
        nonAdditionalPropertyKeys.insert("beacon_user_id")
        nonAdditionalPropertyKeys.insert("created_at")
        nonAdditionalPropertyKeys.insert("type")
        nonAdditionalPropertyKeys.insert("fraud_date")
        nonAdditionalPropertyKeys.insert("fraud_amount")
        nonAdditionalPropertyKeys.insert("audit_trail")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

