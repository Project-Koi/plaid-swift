//
// Item.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Metadata about the Item. */
public struct Item: Codable, JSONEncodable, Hashable {

    public enum UpdateType: String, Codable, CaseIterable {
        case background = "background"
        case userPresentRequired = "user_present_required"
    }
    /** The Plaid Item ID. The `item_id` is always unique; linking the same account at the same institution twice will result in two Items with different `item_id` values. Like all Plaid identifiers, the `item_id` is case-sensitive. */
    public var itemId: String
    /** The Plaid Institution ID associated with the Item. Field is `null` for Items created via Same Day Micro-deposits. */
    public var institutionId: String?
    /** The URL registered to receive webhooks for the Item. */
    public var webhook: String?
    public var error: PlaidError?
    /** A list of products available for the Item that have not yet been accessed. The contents of this array will be mutually exclusive with `billed_products`. */
    public var availableProducts: [Products]
    /** A list of products that have been billed for the Item. The contents of this array will be mutually exclusive with `available_products`. Note - `billed_products` is populated in all environments but only requests in Production are billed. Also note that products that are billed on a pay-per-call basis rather than a pay-per-Item basis, such as `balance`, will not appear here.  */
    public var billedProducts: [Products]
    /** A list of products added to the Item. In almost all cases, this will be the same as the `billed_products` field. For some products, it is possible for the product to be added to an Item but not yet billed (e.g. Assets, before `/asset_report/create` has been called, or Auth or Identity when added as Optional Products but before their endpoints have been called), in which case the product may appear in `products` but not in `billed_products`.  */
    public var products: [Products]?
    /** A list of products that have gone through consent collection for the Item. Only present for those enabled in the [Data Transparency](https://plaid.com/docs/link/data-transparency-messaging-migration-guide) beta. If you are not enrolled in Data Transparency, this field is not used.  */
    public var consentedProducts: [Products]?
    /** The RFC 3339 timestamp after which the consent provided by the end user will expire. Upon consent expiration, the item will enter the `ITEM_LOGIN_REQUIRED` error state. To circumvent the `ITEM_LOGIN_REQUIRED` error and maintain continuous consent, the end user can reauthenticate via Linkâ€™s update mode in advance of the consent expiration time.  Note - This is only relevant for certain OAuth-based institutions. For all other institutions, this field will be null.  */
    public var consentExpirationTime: Date?
    /** Indicates whether an Item requires user interaction to be updated, which can be the case for Items with some forms of two-factor authentication.  `background` - Item can be updated in the background  `user_present_required` - Item requires user interaction to be updated */
    public var updateType: UpdateType

    public init(itemId: String, institutionId: String? = nil, webhook: String?, error: PlaidError?, availableProducts: [Products], billedProducts: [Products], products: [Products]? = nil, consentedProducts: [Products]? = nil, consentExpirationTime: Date?, updateType: UpdateType) {
        self.itemId = itemId
        self.institutionId = institutionId
        self.webhook = webhook
        self.error = error
        self.availableProducts = availableProducts
        self.billedProducts = billedProducts
        self.products = products
        self.consentedProducts = consentedProducts
        self.consentExpirationTime = consentExpirationTime
        self.updateType = updateType
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case itemId = "item_id"
        case institutionId = "institution_id"
        case webhook
        case error
        case availableProducts = "available_products"
        case billedProducts = "billed_products"
        case products
        case consentedProducts = "consented_products"
        case consentExpirationTime = "consent_expiration_time"
        case updateType = "update_type"
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(itemId, forKey: .itemId)
        try container.encodeIfPresent(institutionId, forKey: .institutionId)
        try container.encode(webhook, forKey: .webhook)
        try container.encode(error, forKey: .error)
        try container.encode(availableProducts, forKey: .availableProducts)
        try container.encode(billedProducts, forKey: .billedProducts)
        try container.encodeIfPresent(products, forKey: .products)
        try container.encodeIfPresent(consentedProducts, forKey: .consentedProducts)
        try container.encode(consentExpirationTime, forKey: .consentExpirationTime)
        try container.encode(updateType, forKey: .updateType)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        itemId = try container.decode(String.self, forKey: .itemId)
        institutionId = try container.decodeIfPresent(String.self, forKey: .institutionId)
        webhook = try container.decodeIfPresent(String.self, forKey: .webhook)
        error = try container.decodeIfPresent(PlaidError.self, forKey: .error)
        availableProducts = try container.decode([Products].self, forKey: .availableProducts)
        billedProducts = try container.decode([Products].self, forKey: .billedProducts)
        products = try container.decodeIfPresent([Products].self, forKey: .products)
        consentedProducts = try container.decodeIfPresent([Products].self, forKey: .consentedProducts)
        consentExpirationTime = try container.decodeIfPresent(Date.self, forKey: .consentExpirationTime)
        updateType = try container.decode(UpdateType.self, forKey: .updateType)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("item_id")
        nonAdditionalPropertyKeys.insert("institution_id")
        nonAdditionalPropertyKeys.insert("webhook")
        nonAdditionalPropertyKeys.insert("error")
        nonAdditionalPropertyKeys.insert("available_products")
        nonAdditionalPropertyKeys.insert("billed_products")
        nonAdditionalPropertyKeys.insert("products")
        nonAdditionalPropertyKeys.insert("consented_products")
        nonAdditionalPropertyKeys.insert("consent_expiration_time")
        nonAdditionalPropertyKeys.insert("update_type")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

