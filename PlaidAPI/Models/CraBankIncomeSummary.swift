//
// CraBankIncomeSummary.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Summary for bank income across all income sources and items (max history of 730 days). */
public struct CraBankIncomeSummary: Codable, JSONEncodable, Hashable {

    /** Total amount of earnings across all the income sources in the end user's Items for the days requested by the client. This can contain multiple amounts, with each amount denominated in one unique currency. */
    public var totalAmounts: [CreditAmountWithCurrency]?
    /** The earliest date within the days requested in which all income sources identified by Plaid appear in a user's account. The date will be returned in an ISO 8601 format (YYYY-MM-DD). */
    public var startDate: Date?
    /** The latest date in which all income sources identified by Plaid appear in the user's account. The date will be returned in an ISO 8601 format (YYYY-MM-DD). */
    public var endDate: Date?
    /** Number of income sources per end user. */
    public var incomeSourcesCount: Int?
    /** Number of income categories per end user. */
    public var incomeCategoriesCount: Int?
    /** Number of income transactions per end user. */
    public var incomeTransactionsCount: Int?
    /** An estimate of the average gross monthly income based on the historical net amount and income category for the income source(s). */
    public var historicalAverageMonthlyGrossIncome: [CreditAmountWithCurrency]?
    /** The average monthly income amount estimated based on the historical data for the income source(s). */
    public var historicalAverageMonthlyIncome: [CreditAmountWithCurrency]?
    /** The predicted average monthly income amount for the income source(s). */
    public var forecastedAverageMonthlyIncome: [CreditAmountWithCurrency]?
    /** An estimate of the annual gross income based on the historical net amount and income category for the income source(s). */
    public var historicalAnnualGrossIncome: [CreditAmountWithCurrency]?
    /** The annual income amount estimated based on the historical data for the income source(s). */
    public var historicalAnnualIncome: [CreditAmountWithCurrency]?
    /** The predicted average annual income amount for the income source(s). */
    public var forecastedAnnualIncome: [CreditAmountWithCurrency]?
    public var historicalSummary: [CraBankIncomeHistoricalSummary]?

    public init(totalAmounts: [CreditAmountWithCurrency]? = nil, startDate: Date? = nil, endDate: Date? = nil, incomeSourcesCount: Int? = nil, incomeCategoriesCount: Int? = nil, incomeTransactionsCount: Int? = nil, historicalAverageMonthlyGrossIncome: [CreditAmountWithCurrency]? = nil, historicalAverageMonthlyIncome: [CreditAmountWithCurrency]? = nil, forecastedAverageMonthlyIncome: [CreditAmountWithCurrency]? = nil, historicalAnnualGrossIncome: [CreditAmountWithCurrency]? = nil, historicalAnnualIncome: [CreditAmountWithCurrency]? = nil, forecastedAnnualIncome: [CreditAmountWithCurrency]? = nil, historicalSummary: [CraBankIncomeHistoricalSummary]? = nil) {
        self.totalAmounts = totalAmounts
        self.startDate = startDate
        self.endDate = endDate
        self.incomeSourcesCount = incomeSourcesCount
        self.incomeCategoriesCount = incomeCategoriesCount
        self.incomeTransactionsCount = incomeTransactionsCount
        self.historicalAverageMonthlyGrossIncome = historicalAverageMonthlyGrossIncome
        self.historicalAverageMonthlyIncome = historicalAverageMonthlyIncome
        self.forecastedAverageMonthlyIncome = forecastedAverageMonthlyIncome
        self.historicalAnnualGrossIncome = historicalAnnualGrossIncome
        self.historicalAnnualIncome = historicalAnnualIncome
        self.forecastedAnnualIncome = forecastedAnnualIncome
        self.historicalSummary = historicalSummary
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case totalAmounts = "total_amounts"
        case startDate = "start_date"
        case endDate = "end_date"
        case incomeSourcesCount = "income_sources_count"
        case incomeCategoriesCount = "income_categories_count"
        case incomeTransactionsCount = "income_transactions_count"
        case historicalAverageMonthlyGrossIncome = "historical_average_monthly_gross_income"
        case historicalAverageMonthlyIncome = "historical_average_monthly_income"
        case forecastedAverageMonthlyIncome = "forecasted_average_monthly_income"
        case historicalAnnualGrossIncome = "historical_annual_gross_income"
        case historicalAnnualIncome = "historical_annual_income"
        case forecastedAnnualIncome = "forecasted_annual_income"
        case historicalSummary = "historical_summary"
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(totalAmounts, forKey: .totalAmounts)
        try container.encodeIfPresent(startDate, forKey: .startDate)
        try container.encodeIfPresent(endDate, forKey: .endDate)
        try container.encodeIfPresent(incomeSourcesCount, forKey: .incomeSourcesCount)
        try container.encodeIfPresent(incomeCategoriesCount, forKey: .incomeCategoriesCount)
        try container.encodeIfPresent(incomeTransactionsCount, forKey: .incomeTransactionsCount)
        try container.encodeIfPresent(historicalAverageMonthlyGrossIncome, forKey: .historicalAverageMonthlyGrossIncome)
        try container.encodeIfPresent(historicalAverageMonthlyIncome, forKey: .historicalAverageMonthlyIncome)
        try container.encodeIfPresent(forecastedAverageMonthlyIncome, forKey: .forecastedAverageMonthlyIncome)
        try container.encodeIfPresent(historicalAnnualGrossIncome, forKey: .historicalAnnualGrossIncome)
        try container.encodeIfPresent(historicalAnnualIncome, forKey: .historicalAnnualIncome)
        try container.encodeIfPresent(forecastedAnnualIncome, forKey: .forecastedAnnualIncome)
        try container.encodeIfPresent(historicalSummary, forKey: .historicalSummary)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        totalAmounts = try container.decodeIfPresent([CreditAmountWithCurrency].self, forKey: .totalAmounts)
        startDate = try container.decodeIfPresent(Date.self, forKey: .startDate)
        endDate = try container.decodeIfPresent(Date.self, forKey: .endDate)
        incomeSourcesCount = try container.decodeIfPresent(Int.self, forKey: .incomeSourcesCount)
        incomeCategoriesCount = try container.decodeIfPresent(Int.self, forKey: .incomeCategoriesCount)
        incomeTransactionsCount = try container.decodeIfPresent(Int.self, forKey: .incomeTransactionsCount)
        historicalAverageMonthlyGrossIncome = try container.decodeIfPresent([CreditAmountWithCurrency].self, forKey: .historicalAverageMonthlyGrossIncome)
        historicalAverageMonthlyIncome = try container.decodeIfPresent([CreditAmountWithCurrency].self, forKey: .historicalAverageMonthlyIncome)
        forecastedAverageMonthlyIncome = try container.decodeIfPresent([CreditAmountWithCurrency].self, forKey: .forecastedAverageMonthlyIncome)
        historicalAnnualGrossIncome = try container.decodeIfPresent([CreditAmountWithCurrency].self, forKey: .historicalAnnualGrossIncome)
        historicalAnnualIncome = try container.decodeIfPresent([CreditAmountWithCurrency].self, forKey: .historicalAnnualIncome)
        forecastedAnnualIncome = try container.decodeIfPresent([CreditAmountWithCurrency].self, forKey: .forecastedAnnualIncome)
        historicalSummary = try container.decodeIfPresent([CraBankIncomeHistoricalSummary].self, forKey: .historicalSummary)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("total_amounts")
        nonAdditionalPropertyKeys.insert("start_date")
        nonAdditionalPropertyKeys.insert("end_date")
        nonAdditionalPropertyKeys.insert("income_sources_count")
        nonAdditionalPropertyKeys.insert("income_categories_count")
        nonAdditionalPropertyKeys.insert("income_transactions_count")
        nonAdditionalPropertyKeys.insert("historical_average_monthly_gross_income")
        nonAdditionalPropertyKeys.insert("historical_average_monthly_income")
        nonAdditionalPropertyKeys.insert("forecasted_average_monthly_income")
        nonAdditionalPropertyKeys.insert("historical_annual_gross_income")
        nonAdditionalPropertyKeys.insert("historical_annual_income")
        nonAdditionalPropertyKeys.insert("forecasted_annual_income")
        nonAdditionalPropertyKeys.insert("historical_summary")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

