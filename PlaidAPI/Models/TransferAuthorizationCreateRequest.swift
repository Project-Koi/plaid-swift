//
// TransferAuthorizationCreateRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Defines the request schema for &#x60;/transfer/authorization/create&#x60; */
public struct TransferAuthorizationCreateRequest: Codable, JSONEncodable, Hashable {

    static let idempotencyKeyRule = StringRule(minLength: nil, maxLength: 50, pattern: nil)
    /** Your Plaid API `client_id`. The `client_id` is required and may be provided either in the `PLAID-CLIENT-ID` header or as part of a request body. */
    public var clientId: String?
    /** Your Plaid API `secret`. The `secret` is required and may be provided either in the `PLAID-SECRET` header or as part of a request body. */
    public var secret: String?
    /** The Plaid `access_token` for the account that will be debited or credited. */
    public var accessToken: String
    /** The Plaid `account_id` corresponding to the end-user account that will be debited or credited. */
    public var accountId: String
    /** Specify the account used to fund the transfer. Should be specified if using legacy funding methods only. If using Plaid Ledger, leave this field blank. Customers can find a list of `funding_account_id`s in the Accounts page of your Plaid Dashboard, under the \"Account ID\" column. If this field is left blank and you are using legacy funding methods, this will default to the default `funding_account_id` specified during onboarding. Otherwise, Plaid Ledger will be used. */
    public var fundingAccountId: String?
    /** The payment profile token associated with the Payment Profile that will be debited or credited. Required if not using `access_token`. */
    public var paymentProfileToken: String?
    public var type: TransferType
    public var network: TransferNetwork
    /** The amount of the transfer (decimal string with two digits of precision e.g. \"10.00\"). When calling `/transfer/authorization/create`, specify the maximum amount to authorize. When calling `/transfer/create`, specify the exact amount of the transfer, up to a maximum of the amount authorized. If this field is left blank when calling `/transfer/create`, the maximum amount authorized in the `authorization_id` will be sent. */
    public var amount: String
    public var achClass: ACHClass?
    public var wireDetails: TransferWireDetails?
    public var user: TransferAuthorizationUserInRequest
    public var device: TransferAuthorizationDevice?
    /** Plaid's unique identifier for the origination account for this authorization. If not specified, the default account will be used. */
    @available(*, deprecated, message: "This property is deprecated.")
    public var originationAccountId: String?
    /** The currency of the transfer amount. The default value is \"USD\". */
    public var isoCurrencyCode: String?
    /** A random key provided by the client, per unique authorization, which expires after 48 hours. Maximum of 50 characters.  The API supports idempotency for safely retrying requests without accidentally performing the same operation twice. For example, if a request to create an authorization fails due to a network connection error, you can retry the request with the same idempotency key to guarantee that only a single authorization is created.  This idempotency key expires after 48 hours, after which the same key can be reused. Failure to provide this key may result in duplicate charges. */
    public var idempotencyKey: String?
    /** If the end user is initiating the specific transfer themselves via an interactive UI, this should be `true`; for automatic recurring payments where the end user is not actually initiating each individual transfer, it should be `false`. This field is not currently used and is present to support planned future functionality. */
    public var userPresent: Bool?
    /** If set to `false`, Plaid will not offer a `guarantee_decision` for this request (Guarantee customers only). */
    public var withGuarantee: Bool? = true
    /** The unique identifier returned by Plaid's [beacon](https://plaid.com/docs/transfer/guarantee/#using-a-beacon) when it is run on your webpage. */
    public var beaconSessionId: String?
    /** The Plaid client ID that is the originator of this transfer. Only needed if creating transfers on behalf of another client as a [Platform customer](https://plaid.com/docs/transfer/application/#originators-vs-platforms). */
    public var originatorClientId: String?
    @available(*, deprecated, message: "This property is deprecated.")
    public var creditFundsSource: TransferCreditFundsSource?
    /** Plaidâ€™s unique identifier for a test clock. This field may only be used when using `sandbox` environment. If provided, the `authorization` is created at the `virtual_time` on the provided test clock. */
    public var testClockId: String?

    public init(clientId: String? = nil, secret: String? = nil, accessToken: String, accountId: String, fundingAccountId: String? = nil, paymentProfileToken: String? = nil, type: TransferType, network: TransferNetwork, amount: String, achClass: ACHClass? = nil, wireDetails: TransferWireDetails? = nil, user: TransferAuthorizationUserInRequest, device: TransferAuthorizationDevice? = nil, originationAccountId: String? = nil, isoCurrencyCode: String? = nil, idempotencyKey: String? = nil, userPresent: Bool? = nil, withGuarantee: Bool? = true, beaconSessionId: String? = nil, originatorClientId: String? = nil, creditFundsSource: TransferCreditFundsSource? = nil, testClockId: String? = nil) {
        self.clientId = clientId
        self.secret = secret
        self.accessToken = accessToken
        self.accountId = accountId
        self.fundingAccountId = fundingAccountId
        self.paymentProfileToken = paymentProfileToken
        self.type = type
        self.network = network
        self.amount = amount
        self.achClass = achClass
        self.wireDetails = wireDetails
        self.user = user
        self.device = device
        self.originationAccountId = originationAccountId
        self.isoCurrencyCode = isoCurrencyCode
        self.idempotencyKey = idempotencyKey
        self.userPresent = userPresent
        self.withGuarantee = withGuarantee
        self.beaconSessionId = beaconSessionId
        self.originatorClientId = originatorClientId
        self.creditFundsSource = creditFundsSource
        self.testClockId = testClockId
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case clientId = "client_id"
        case secret
        case accessToken = "access_token"
        case accountId = "account_id"
        case fundingAccountId = "funding_account_id"
        case paymentProfileToken = "payment_profile_token"
        case type
        case network
        case amount
        case achClass = "ach_class"
        case wireDetails = "wire_details"
        case user
        case device
        case originationAccountId = "origination_account_id"
        case isoCurrencyCode = "iso_currency_code"
        case idempotencyKey = "idempotency_key"
        case userPresent = "user_present"
        case withGuarantee = "with_guarantee"
        case beaconSessionId = "beacon_session_id"
        case originatorClientId = "originator_client_id"
        case creditFundsSource = "credit_funds_source"
        case testClockId = "test_clock_id"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(clientId, forKey: .clientId)
        try container.encodeIfPresent(secret, forKey: .secret)
        try container.encode(accessToken, forKey: .accessToken)
        try container.encode(accountId, forKey: .accountId)
        try container.encodeIfPresent(fundingAccountId, forKey: .fundingAccountId)
        try container.encodeIfPresent(paymentProfileToken, forKey: .paymentProfileToken)
        try container.encode(type, forKey: .type)
        try container.encode(network, forKey: .network)
        try container.encode(amount, forKey: .amount)
        try container.encodeIfPresent(achClass, forKey: .achClass)
        try container.encodeIfPresent(wireDetails, forKey: .wireDetails)
        try container.encode(user, forKey: .user)
        try container.encodeIfPresent(device, forKey: .device)
        try container.encodeIfPresent(originationAccountId, forKey: .originationAccountId)
        try container.encodeIfPresent(isoCurrencyCode, forKey: .isoCurrencyCode)
        try container.encodeIfPresent(idempotencyKey, forKey: .idempotencyKey)
        try container.encodeIfPresent(userPresent, forKey: .userPresent)
        try container.encodeIfPresent(withGuarantee, forKey: .withGuarantee)
        try container.encodeIfPresent(beaconSessionId, forKey: .beaconSessionId)
        try container.encodeIfPresent(originatorClientId, forKey: .originatorClientId)
        try container.encodeIfPresent(creditFundsSource, forKey: .creditFundsSource)
        try container.encodeIfPresent(testClockId, forKey: .testClockId)
    }
}

