//
// OverrideAccounts.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Data to use to set values of test accounts. Some values cannot be specified in the schema and will instead will be calculated from other test data in order to achieve more consistent, realistic test data. */
public struct OverrideAccounts: Codable, JSONEncodable, Hashable {

    public var type: OverrideAccountType
    public var subtype: AccountSubtype?
    /** If provided, the account will start with this amount as the current balance.  */
    public var startingBalance: Double
    /** If provided, the account will always have this amount as its  available balance, regardless of current balance or changes in transactions over time. */
    public var forceAvailableBalance: Double
    /** ISO-4217 currency code. If provided, the account will be denominated in the given currency. Transactions will also be in this currency by default. */
    public var currency: String
    public var meta: Meta
    public var numbers: Numbers
    /** Specify the list of transactions on the account. */
    public var transactions: [TransactionOverride]
    public var holdings: HoldingsOverride?
    public var investmentTransactions: InvestmentsTransactionsOverride?
    public var identity: OwnerOverride
    public var liability: LiabilityOverride
    public var inflowModel: InflowModel
    public var income: IncomeOverride?

    public init(type: OverrideAccountType, subtype: AccountSubtype?, startingBalance: Double, forceAvailableBalance: Double, currency: String, meta: Meta, numbers: Numbers, transactions: [TransactionOverride], holdings: HoldingsOverride? = nil, investmentTransactions: InvestmentsTransactionsOverride? = nil, identity: OwnerOverride, liability: LiabilityOverride, inflowModel: InflowModel, income: IncomeOverride? = nil) {
        self.type = type
        self.subtype = subtype
        self.startingBalance = startingBalance
        self.forceAvailableBalance = forceAvailableBalance
        self.currency = currency
        self.meta = meta
        self.numbers = numbers
        self.transactions = transactions
        self.holdings = holdings
        self.investmentTransactions = investmentTransactions
        self.identity = identity
        self.liability = liability
        self.inflowModel = inflowModel
        self.income = income
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case type
        case subtype
        case startingBalance = "starting_balance"
        case forceAvailableBalance = "force_available_balance"
        case currency
        case meta
        case numbers
        case transactions
        case holdings
        case investmentTransactions = "investment_transactions"
        case identity
        case liability
        case inflowModel = "inflow_model"
        case income
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(type, forKey: .type)
        try container.encode(subtype, forKey: .subtype)
        try container.encode(startingBalance, forKey: .startingBalance)
        try container.encode(forceAvailableBalance, forKey: .forceAvailableBalance)
        try container.encode(currency, forKey: .currency)
        try container.encode(meta, forKey: .meta)
        try container.encode(numbers, forKey: .numbers)
        try container.encode(transactions, forKey: .transactions)
        try container.encodeIfPresent(holdings, forKey: .holdings)
        try container.encodeIfPresent(investmentTransactions, forKey: .investmentTransactions)
        try container.encode(identity, forKey: .identity)
        try container.encode(liability, forKey: .liability)
        try container.encode(inflowModel, forKey: .inflowModel)
        try container.encodeIfPresent(income, forKey: .income)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        type = try container.decode(OverrideAccountType.self, forKey: .type)
        subtype = try container.decodeIfPresent(AccountSubtype.self, forKey: .subtype)
        startingBalance = try container.decode(Double.self, forKey: .startingBalance)
        forceAvailableBalance = try container.decode(Double.self, forKey: .forceAvailableBalance)
        currency = try container.decode(String.self, forKey: .currency)
        meta = try container.decode(Meta.self, forKey: .meta)
        numbers = try container.decode(Numbers.self, forKey: .numbers)
        transactions = try container.decode([TransactionOverride].self, forKey: .transactions)
        holdings = try container.decodeIfPresent(HoldingsOverride.self, forKey: .holdings)
        investmentTransactions = try container.decodeIfPresent(InvestmentsTransactionsOverride.self, forKey: .investmentTransactions)
        identity = try container.decode(OwnerOverride.self, forKey: .identity)
        liability = try container.decode(LiabilityOverride.self, forKey: .liability)
        inflowModel = try container.decode(InflowModel.self, forKey: .inflowModel)
        income = try container.decodeIfPresent(IncomeOverride.self, forKey: .income)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("type")
        nonAdditionalPropertyKeys.insert("subtype")
        nonAdditionalPropertyKeys.insert("starting_balance")
        nonAdditionalPropertyKeys.insert("force_available_balance")
        nonAdditionalPropertyKeys.insert("currency")
        nonAdditionalPropertyKeys.insert("meta")
        nonAdditionalPropertyKeys.insert("numbers")
        nonAdditionalPropertyKeys.insert("transactions")
        nonAdditionalPropertyKeys.insert("holdings")
        nonAdditionalPropertyKeys.insert("investment_transactions")
        nonAdditionalPropertyKeys.insert("identity")
        nonAdditionalPropertyKeys.insert("liability")
        nonAdditionalPropertyKeys.insert("inflow_model")
        nonAdditionalPropertyKeys.insert("income")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

