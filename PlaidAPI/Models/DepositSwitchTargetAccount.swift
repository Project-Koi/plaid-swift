//
// DepositSwitchTargetAccount.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** The deposit switch destination account */
public struct DepositSwitchTargetAccount: Codable, JSONEncodable, Hashable {

    public enum AccountSubtype: String, Codable, CaseIterable {
        case checking = "checking"
        case savings = "savings"
    }
    /** Account number for deposit switch destination */
    public var accountNumber: String
    /** Routing number for deposit switch destination */
    public var routingNumber: String
    /** The name of the deposit switch destination account, as it will be displayed to the end user in the Deposit Switch interface. It is not required to match the name used in online banking. */
    public var accountName: String
    /** The account subtype of the account, either `checking` or `savings`. */
    public var accountSubtype: AccountSubtype

    public init(accountNumber: String, routingNumber: String, accountName: String, accountSubtype: AccountSubtype) {
        self.accountNumber = accountNumber
        self.routingNumber = routingNumber
        self.accountName = accountName
        self.accountSubtype = accountSubtype
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case accountNumber = "account_number"
        case routingNumber = "routing_number"
        case accountName = "account_name"
        case accountSubtype = "account_subtype"
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(accountNumber, forKey: .accountNumber)
        try container.encode(routingNumber, forKey: .routingNumber)
        try container.encode(accountName, forKey: .accountName)
        try container.encode(accountSubtype, forKey: .accountSubtype)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        accountNumber = try container.decode(String.self, forKey: .accountNumber)
        routingNumber = try container.decode(String.self, forKey: .routingNumber)
        accountName = try container.decode(String.self, forKey: .accountName)
        accountSubtype = try container.decode(AccountSubtype.self, forKey: .accountSubtype)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("account_number")
        nonAdditionalPropertyKeys.insert("routing_number")
        nonAdditionalPropertyKeys.insert("account_name")
        nonAdditionalPropertyKeys.insert("account_subtype")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

