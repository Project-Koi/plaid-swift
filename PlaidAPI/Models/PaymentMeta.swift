//
// PaymentMeta.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Transaction information specific to inter-bank transfers. If the transaction was not an inter-bank transfer, all fields will be &#x60;null&#x60;.  If the &#x60;transactions&#x60; object was returned by a Transactions endpoint such as &#x60;/transactions/sync&#x60; or &#x60;/transactions/get&#x60;, the &#x60;payment_meta&#x60; key will always appear, but no data elements are guaranteed. If the &#x60;transactions&#x60; object was returned by an Assets endpoint such as &#x60;/asset_report/get/&#x60; or &#x60;/asset_report/pdf/get&#x60;, this field will only appear in an Asset Report with Insights. */
public struct PaymentMeta: Codable, JSONEncodable, Hashable {

    /** The transaction reference number supplied by the financial institution. */
    public var referenceNumber: String?
    /** The ACH PPD ID for the payer. */
    public var ppdId: String?
    /** For transfers, the party that is receiving the transaction. */
    public var payee: String?
    /** The party initiating a wire transfer. Will be `null` if the transaction is not a wire transfer. */
    public var byOrderOf: String?
    /** For transfers, the party that is paying the transaction. */
    public var payer: String?
    /** The type of transfer, e.g. 'ACH' */
    public var paymentMethod: String?
    /** The name of the payment processor */
    public var paymentProcessor: String?
    /** The payer-supplied description of the transfer. */
    public var reason: String?

    public init(referenceNumber: String?, ppdId: String?, payee: String?, byOrderOf: String?, payer: String?, paymentMethod: String?, paymentProcessor: String?, reason: String?) {
        self.referenceNumber = referenceNumber
        self.ppdId = ppdId
        self.payee = payee
        self.byOrderOf = byOrderOf
        self.payer = payer
        self.paymentMethod = paymentMethod
        self.paymentProcessor = paymentProcessor
        self.reason = reason
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case referenceNumber = "reference_number"
        case ppdId = "ppd_id"
        case payee
        case byOrderOf = "by_order_of"
        case payer
        case paymentMethod = "payment_method"
        case paymentProcessor = "payment_processor"
        case reason
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(referenceNumber, forKey: .referenceNumber)
        try container.encode(ppdId, forKey: .ppdId)
        try container.encode(payee, forKey: .payee)
        try container.encode(byOrderOf, forKey: .byOrderOf)
        try container.encode(payer, forKey: .payer)
        try container.encode(paymentMethod, forKey: .paymentMethod)
        try container.encode(paymentProcessor, forKey: .paymentProcessor)
        try container.encode(reason, forKey: .reason)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        referenceNumber = try container.decodeIfPresent(String.self, forKey: .referenceNumber)
        ppdId = try container.decodeIfPresent(String.self, forKey: .ppdId)
        payee = try container.decodeIfPresent(String.self, forKey: .payee)
        byOrderOf = try container.decodeIfPresent(String.self, forKey: .byOrderOf)
        payer = try container.decodeIfPresent(String.self, forKey: .payer)
        paymentMethod = try container.decodeIfPresent(String.self, forKey: .paymentMethod)
        paymentProcessor = try container.decodeIfPresent(String.self, forKey: .paymentProcessor)
        reason = try container.decodeIfPresent(String.self, forKey: .reason)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("reference_number")
        nonAdditionalPropertyKeys.insert("ppd_id")
        nonAdditionalPropertyKeys.insert("payee")
        nonAdditionalPropertyKeys.insert("by_order_of")
        nonAdditionalPropertyKeys.insert("payer")
        nonAdditionalPropertyKeys.insert("payment_method")
        nonAdditionalPropertyKeys.insert("payment_processor")
        nonAdditionalPropertyKeys.insert("reason")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

