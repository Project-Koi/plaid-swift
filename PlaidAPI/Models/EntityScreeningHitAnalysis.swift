//
// EntityScreeningHitAnalysis.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Analysis information describing why a screening hit matched the provided entity information */
public struct EntityScreeningHitAnalysis: Codable, JSONEncodable, Hashable {

    public var documents: MatchSummaryCode?
    public var emailAddresses: MatchSummaryCode?
    public var locations: MatchSummaryCode?
    public var names: MatchSummaryCode?
    public var phoneNumbers: MatchSummaryCode?
    public var urls: MatchSummaryCode?
    /** The version of the entity screening's `search_terms` that were compared when the entity screening hit was added. entity screening hits are immutable once they have been reviewed. If changes are detected due to updates to the entity screening's `search_terms`, the associated entity program, or the list's source data prior to review, the entity screening hit will be updated to reflect those changes. */
    public var searchTermsVersion: Int

    public init(documents: MatchSummaryCode? = nil, emailAddresses: MatchSummaryCode? = nil, locations: MatchSummaryCode? = nil, names: MatchSummaryCode? = nil, phoneNumbers: MatchSummaryCode? = nil, urls: MatchSummaryCode? = nil, searchTermsVersion: Int) {
        self.documents = documents
        self.emailAddresses = emailAddresses
        self.locations = locations
        self.names = names
        self.phoneNumbers = phoneNumbers
        self.urls = urls
        self.searchTermsVersion = searchTermsVersion
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case documents
        case emailAddresses = "email_addresses"
        case locations
        case names
        case phoneNumbers = "phone_numbers"
        case urls
        case searchTermsVersion = "search_terms_version"
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(documents, forKey: .documents)
        try container.encodeIfPresent(emailAddresses, forKey: .emailAddresses)
        try container.encodeIfPresent(locations, forKey: .locations)
        try container.encodeIfPresent(names, forKey: .names)
        try container.encodeIfPresent(phoneNumbers, forKey: .phoneNumbers)
        try container.encodeIfPresent(urls, forKey: .urls)
        try container.encode(searchTermsVersion, forKey: .searchTermsVersion)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        documents = try container.decodeIfPresent(MatchSummaryCode.self, forKey: .documents)
        emailAddresses = try container.decodeIfPresent(MatchSummaryCode.self, forKey: .emailAddresses)
        locations = try container.decodeIfPresent(MatchSummaryCode.self, forKey: .locations)
        names = try container.decodeIfPresent(MatchSummaryCode.self, forKey: .names)
        phoneNumbers = try container.decodeIfPresent(MatchSummaryCode.self, forKey: .phoneNumbers)
        urls = try container.decodeIfPresent(MatchSummaryCode.self, forKey: .urls)
        searchTermsVersion = try container.decode(Int.self, forKey: .searchTermsVersion)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("documents")
        nonAdditionalPropertyKeys.insert("email_addresses")
        nonAdditionalPropertyKeys.insert("locations")
        nonAdditionalPropertyKeys.insert("names")
        nonAdditionalPropertyKeys.insert("phone_numbers")
        nonAdditionalPropertyKeys.insert("urls")
        nonAdditionalPropertyKeys.insert("search_terms_version")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

