//
// BeaconAccountRiskEvaluateRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** BeaconAccountRiskEvaluateRequest defines the request schema for &#x60;/v1/beacon/account_risk/risk/evaluate&#x60; */
public struct BeaconAccountRiskEvaluateRequest: Codable, JSONEncodable, Hashable {

    static let clientUserIdRule = StringRule(minLength: 1, maxLength: 36, pattern: nil)
    /** Your Plaid API `client_id`. The `client_id` is required and may be provided either in the `PLAID-CLIENT-ID` header or as part of a request body. */
    public var clientId: String?
    /** Your Plaid API `secret`. The `secret` is required and may be provided either in the `PLAID-SECRET` header or as part of a request body. */
    public var secret: String?
    /** The access token associated with the Item data is being requested for. */
    public var accessToken: String?
    public var options: BeaconAccountRiskEvaluateRequestOptions?
    /** A unique ID that identifies the end user in your system. This ID is used to correlate requests by a user with multiple evaluations and/or multiple linked accounts. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id. */
    public var clientUserId: String?
    /** Unique identifier of what you are looking to evaluate (account add, information change, etc.) to allow us to tie the activity to the decisions and possible fraud outcome sent via our feedback endpoints. You can use your internal request ID or similar. */
    public var clientEvaluationId: String?
    public var evaluationReason: BeaconAccountRiskEvaluateEvaluationReason?
    public var device: SignalDevice?
    /** The time the event for evaluation has occurred. Populate this field for backfilling data. If you don’t populate this field, we’ll use the timestamp at the time of receipt. Use ISO 8601 format (YYYY-MM-DDTHH:mm:ssZ). */
    public var evaluateTime: String?

    public init(clientId: String? = nil, secret: String? = nil, accessToken: String? = nil, options: BeaconAccountRiskEvaluateRequestOptions? = nil, clientUserId: String? = nil, clientEvaluationId: String? = nil, evaluationReason: BeaconAccountRiskEvaluateEvaluationReason? = nil, device: SignalDevice? = nil, evaluateTime: String? = nil) {
        self.clientId = clientId
        self.secret = secret
        self.accessToken = accessToken
        self.options = options
        self.clientUserId = clientUserId
        self.clientEvaluationId = clientEvaluationId
        self.evaluationReason = evaluationReason
        self.device = device
        self.evaluateTime = evaluateTime
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case clientId = "client_id"
        case secret
        case accessToken = "access_token"
        case options
        case clientUserId = "client_user_id"
        case clientEvaluationId = "client_evaluation_id"
        case evaluationReason = "evaluation_reason"
        case device
        case evaluateTime = "evaluate_time"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(clientId, forKey: .clientId)
        try container.encodeIfPresent(secret, forKey: .secret)
        try container.encodeIfPresent(accessToken, forKey: .accessToken)
        try container.encodeIfPresent(options, forKey: .options)
        try container.encodeIfPresent(clientUserId, forKey: .clientUserId)
        try container.encodeIfPresent(clientEvaluationId, forKey: .clientEvaluationId)
        try container.encodeIfPresent(evaluationReason, forKey: .evaluationReason)
        try container.encodeIfPresent(device, forKey: .device)
        try container.encodeIfPresent(evaluateTime, forKey: .evaluateTime)
    }
}

