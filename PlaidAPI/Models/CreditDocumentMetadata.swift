//
// CreditDocumentMetadata.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Object representing metadata pertaining to the document. */
public struct CreditDocumentMetadata: Codable, JSONEncodable, Hashable {

    /** The name of the document. */
    public var name: String
    /** The type of document.  `PAYSTUB`: A paystub.  `BANK_STATEMENT`: A bank statement.  `US_TAX_W2`: A W-2 wage and tax statement provided by a US employer reflecting wages earned by the employee.  `US_MILITARY_ERAS`: An electronic Retirement Account Statement (eRAS) issued by the US military.  `US_MILITARY_LES`: A Leave and Earnings Statement (LES) issued by the US military.  `US_MILITARY_CLES`: A Civilian Leave and Earnings Statment (CLES) issued by the US military.  `GIG`: Used to indicate that the income is related to gig work. Does not necessarily correspond to a specific document type.  `PLAID_GENERATED_PAYSTUB_PDF`: Used to indicate that the PDF for the paystub was generated by Plaid.  `NONE`: Used to indicate that there is no underlying document for the data.  `UNKNOWN`: Document type could not be determined. */
    public var documentType: String?
    /** Signed URL to retrieve the underlying file. For Payroll Income, the file type will always be PDF, and the file may not be available, in which case the field will be `null`. If you would like Plaid to generate a PDF if the original is not available, contact your Account Manager. [Example generated pay stub](https://www.plaid.com/documents/plaid-generated-mock-paystub.pdf).  For Document Income, this field will not be `null`, and the file type will be the original file type uploaded by the user. For more details on available file types, see the [Document Income](https://www.plaid.com/docs/income/payroll-income) documentation.  This download URL can only be used once and expires after two minutes. To generate a new download URL, call `/credit/payroll_income/get` again. */
    public var downloadUrl: String?
    /** The processing status of the document.  `PROCESSING_COMPLETE`: The document was successfully processed.  `DOCUMENT_ERROR`: The document could not be processed. Possible causes include: The document was an unacceptable document type such as an offer letter or bank statement, the document image was cropped or blurry, or the document was corrupted.  `UNKNOWN` or `null`: An internal error occurred. If this happens repeatedly, contact support or your Plaid account manager. */
    public var status: String?
    /** The number of pages of the uploaded document (if available). */
    public var pageCount: Int?

    public init(name: String, documentType: String?, downloadUrl: String?, status: String?, pageCount: Int? = nil) {
        self.name = name
        self.documentType = documentType
        self.downloadUrl = downloadUrl
        self.status = status
        self.pageCount = pageCount
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case name
        case documentType = "document_type"
        case downloadUrl = "download_url"
        case status
        case pageCount = "page_count"
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(name, forKey: .name)
        try container.encode(documentType, forKey: .documentType)
        try container.encode(downloadUrl, forKey: .downloadUrl)
        try container.encode(status, forKey: .status)
        try container.encodeIfPresent(pageCount, forKey: .pageCount)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        name = try container.decode(String.self, forKey: .name)
        documentType = try container.decodeIfPresent(String.self, forKey: .documentType)
        downloadUrl = try container.decodeIfPresent(String.self, forKey: .downloadUrl)
        status = try container.decodeIfPresent(String.self, forKey: .status)
        pageCount = try container.decodeIfPresent(Int.self, forKey: .pageCount)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("name")
        nonAdditionalPropertyKeys.insert("document_type")
        nonAdditionalPropertyKeys.insert("download_url")
        nonAdditionalPropertyKeys.insert("status")
        nonAdditionalPropertyKeys.insert("page_count")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

