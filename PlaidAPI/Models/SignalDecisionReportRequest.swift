//
// SignalDecisionReportRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** SignalDecisionReportRequest defines the request schema for &#x60;/signal/decision/report&#x60; */
public struct SignalDecisionReportRequest: Codable, JSONEncodable, Hashable {

    static let clientTransactionIdRule = StringRule(minLength: 1, maxLength: 36, pattern: nil)
    static let daysFundsOnHoldRule = NumericRule<Int>(minimum: 0, exclusiveMinimum: false, maximum: nil, exclusiveMaximum: false, multipleOf: nil)
    /** Your Plaid API `client_id`. The `client_id` is required and may be provided either in the `PLAID-CLIENT-ID` header or as part of a request body. */
    public var clientId: String?
    /** Your Plaid API `secret`. The `secret` is required and may be provided either in the `PLAID-SECRET` header or as part of a request body. */
    public var secret: String?
    /** Must be the same as the `client_transaction_id` supplied when calling `/signal/evaluate` */
    public var clientTransactionId: String
    /** `true` if the ACH transaction was initiated, `false` otherwise.  This field must be returned as a boolean. If formatted incorrectly, this will result in an [`INVALID_FIELD`](/docs/errors/invalid-request/#invalid_field) error. */
    public var initiated: Bool
    /** The actual number of days (hold time) since the ACH debit transaction that you wait before making funds available to your customers. The holding time could affect the ACH return rate.  For example, use 0 if you make funds available to your customers instantly or the same day following the debit transaction, or 1 if you make funds available the next day following the debit initialization. */
    public var daysFundsOnHold: Int?
    public var decisionOutcome: SignalDecisionOutcome?
    public var paymentMethod: SignalPaymentMethod?
    /** The amount (in USD) made available to your customers instantly following the debit transaction. It could be a partial amount of the requested transaction (example: 102.05). */
    public var amountInstantlyAvailable: Double?

    public init(clientId: String? = nil, secret: String? = nil, clientTransactionId: String, initiated: Bool, daysFundsOnHold: Int? = nil, decisionOutcome: SignalDecisionOutcome? = nil, paymentMethod: SignalPaymentMethod? = nil, amountInstantlyAvailable: Double? = nil) {
        self.clientId = clientId
        self.secret = secret
        self.clientTransactionId = clientTransactionId
        self.initiated = initiated
        self.daysFundsOnHold = daysFundsOnHold
        self.decisionOutcome = decisionOutcome
        self.paymentMethod = paymentMethod
        self.amountInstantlyAvailable = amountInstantlyAvailable
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case clientId = "client_id"
        case secret
        case clientTransactionId = "client_transaction_id"
        case initiated
        case daysFundsOnHold = "days_funds_on_hold"
        case decisionOutcome = "decision_outcome"
        case paymentMethod = "payment_method"
        case amountInstantlyAvailable = "amount_instantly_available"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(clientId, forKey: .clientId)
        try container.encodeIfPresent(secret, forKey: .secret)
        try container.encode(clientTransactionId, forKey: .clientTransactionId)
        try container.encode(initiated, forKey: .initiated)
        try container.encodeIfPresent(daysFundsOnHold, forKey: .daysFundsOnHold)
        try container.encodeIfPresent(decisionOutcome, forKey: .decisionOutcome)
        try container.encodeIfPresent(paymentMethod, forKey: .paymentMethod)
        try container.encodeIfPresent(amountInstantlyAvailable, forKey: .amountInstantlyAvailable)
    }
}

